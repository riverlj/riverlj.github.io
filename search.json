[{"title":"flutter 导航详解","url":"/2019/06/23/flutter-导航详解/","content":"\n### 概述\n\n路由在我们开发的App中起着\"起承转合\"的作用，今天这篇文章总结一下Flutter的路由使用，通过阅读本文，你能了解到如下内容：\n\n- 使用Hero制作动画转场。\n- Push 和 back。\n- 通过namePush转场。\n- 跳转到下个页面并携带参数。\n- 返回并带回参数。\n- 将数据发送到新页面。\n\n### Hero\n\n通过`Hero`标签指定两个锚点，在两个页面转换的过程中展示转场动画。\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass NavigationHero extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'hero 转场',\n      home: MainScreen(),\n    );\n  }\n}\n\nclass MainScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text('main screen'),\n        ),\n        body: GestureDetector(\n          child: Center(\n            // 关键代码\n              child: Hero(\n                  tag: 'imageHero',\n                  child: Image.network('https://picsum.photos/250?image=9'))),\n          onTap: () {\n            Navigator.push(\n                context,\n                MaterialPageRoute(\n                    builder: (_) {\n                      return DetailScreen();\n                    },\n                    fullscreenDialog: true));\n          },\n        ));\n  }\n}\n\nclass DetailScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n          child: GestureDetector(\n\t\t\t\t// 关键代码\n        child: Hero(\n            tag: 'imageHero',\n            child: Image.network('https://picsum.photos/250?image=9')),\n        onTap: () {\n          Navigator.pop(context);\n        },\n      )),\n    );\n  }\n}\n\n```\n\n执行效果\n\n![hero](https://riverli.oss-cn-beijing.aliyuncs.com/image/1561275130.gif)\n\n在iOS项目中有个类似的Swift框架叫Hero，感兴趣的朋友可以去GitHub查看。\n\n### Push and Back\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass NavigationPushAndBack extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return FirstRoute();\n  }\n}\n\nclass FirstRoute extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('First Route'),\n      ),\n      body: Center(\n        child: RaisedButton(\n          onPressed: () {\n            //关键代码\n            Navigator.push(context,\n                MaterialPageRoute(builder: (context) => SecondRoute()));\n          },\n          child: Text('Open Route'),\n        ),\n      ),\n    );\n  }\n}\n\nclass SecondRoute extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    // TODO: implement build\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Sencond Route'),\n      ),\n      body: Center(\n        child: RaisedButton(\n          onPressed: () {\n            //关键代码\n            Navigator.pop(context);\n          },\n          child: Text('Go Back'),\n        ),\n      ),\n    );\n  }\n}\n\n```\n\n执行效果\n\n![push&back](https://riverli.oss-cn-beijing.aliyuncs.com/image/1561275131.gif)\n\n### 导航的时候携带参数\n\n跳转的时候携带参数有两种方式：\n\n- 通过push的时候携带RouteSettings\n- 通过pushNamed在onGenerateRoute中配置参数。\n- onGenerateRoute配置有些\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass ScreenArguments {\n  final String title;\n  final String message;\n  ScreenArguments(this.title, this.message);\n}\n\nclass PassArgumentScreen extends StatelessWidget {\n  static const routeName = '/passArguments';\n\n  final String title;\n  final String message;\n\n  const PassArgumentScreen(\n      {Key key, @required this.title, @required this.message})\n      : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(title),\n      ),\n      body: Center(\n        child: Text(message),\n      ),\n    );\n  }\n}\n\nclass ExtractArgumentsScreen extends StatelessWidget {\n  static const routeName = '/extractArguments';\n\n  @override\n  Widget build(BuildContext context) {\n    final ScreenArguments args = ModalRoute.of(context).settings.arguments;\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(args.title),\n      ),\n      body: Center(\n        child: Text(args.message),\n      ),\n    );\n  }\n}\n\nclass HomeScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Home Screen'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            RaisedButton(\n              child: Text('跳转到 extracts arguments'),\n              onPressed: () {\n                Navigator.push(\n                    context,\n                    MaterialPageRoute(\n                        builder: (_) {\n                          return ExtractArgumentsScreen();\n                        },\n                        settings: RouteSettings(\n                          arguments: ScreenArguments('Extract Arguments Screen',\n                              'This message is extracted in the build method'),\n                        )));\n              },\n            ),\n            RaisedButton(\n              child: Text('Navigate to a named that accepts arguments'),\n              onPressed: () {\n                Navigator.pushNamed(context, PassArgumentScreen.routeName,\n                    arguments: ScreenArguments('Accept Arguments Screen',\n                        'This message is extracted in the onGenerateRoute function.'));\n              },\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}\n\nclass PassArgumentsScreen extends StatelessWidget {\n  static const routeName = '/passArguments';\n  final String title;\n  final String message;\n\n  const PassArgumentsScreen(\n      {Key key, @required this.title, @required this.message})\n      : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(title),\n      ),\n      body: Center(\n        child: Text(message),\n      ),\n    );\n  }\n}\n\n\n//main.dart\nvoid main() => runApp(MyApp());\n\nclass MyApp extends StatelessWidget {\n  // This widget is the root of your application.\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      initialRoute: '/',\n      onGenerateRoute: (settings) {\n        if(settings.name == PassArgumentsScreen.routeName) {\n          final ScreenArguments args = settings.arguments;\n\n          return MaterialPageRoute(\n            builder: (context) {\n              return PassArgumentScreen(\n                title: args.title,\n                message: args.message,\n              );\n            }\n          );\n        }\n      },\n      title: 'Flutter Demo',\n      theme: ThemeData(\n        primarySwatch: Colors.blue,\n      ),\n      home: Home()\n    );\n  }\n}\n```\n\n效果图：\n\n![携带参数](https://riverli.oss-cn-beijing.aliyuncs.com/image/1561275132.gif)\n\n### 页面返回的时候携带参数\n\n```dart\nimport 'package:flutter/material.dart';\n\nclass NavigationReturnDataFromScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Return Data Demo'),\n      ),\n      body: Center(child: SelectionButton()),\n    );\n  }\n}\n\nclass SelectionButton extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return RaisedButton(\n      onPressed: () {\n        _navigateAndDisplaySelection(context);\n      },\n      child: Text('Pick an option, any option!'),\n    );\n  }\n\n  _navigateAndDisplaySelection(BuildContext context) async {\n    final result = await Navigator.push(\n        context, MaterialPageRoute(builder: (context) => SelectionScreen()));\n    Scaffold.of(context)\n      ..removeCurrentSnackBar()\n      ..showSnackBar(SnackBar(content: Text(\"$result\")));\n  }\n}\n\nclass SelectionScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('Pick an option'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: RaisedButton(\n                onPressed: () {\n                  Navigator.pop(context, 'Yep!');\n                },\n                child: Text('Yep!'),\n              ),\n            ),\n            Padding(\n              padding: const EdgeInsets.all(8.0),\n              child: RaisedButton(\n                onPressed: () {\n                  Navigator.pop(context, 'Nope.');\n                },\n                child: Text('Nope.'),\n              ),\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}\n```\n\n运行效果：\n\n![backData](https://riverli.oss-cn-beijing.aliyuncs.com/image/1561275132.gif)\n\n### 将数据发送到新页面\n\n```dart\nimport 'package:flutter/material.dart';\nimport 'package:flutter/foundation.dart';\n\nclass NavigationSendDataToScreen extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: TodosScreen(\n          todos: List.generate(\n              20,\n              (i) => Todo('Todo $i',\n                  'A description of what needs to be done for Todo $i'))),\n    );\n  }\n}\n\nclass Todo {\n  final String title;\n  final String description;\n\n  Todo(this.title, this.description);\n}\n\nclass TodosScreen extends StatelessWidget {\n  final List<Todo> todos;\n\n  TodosScreen({Key key, @required this.todos}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n        appBar: AppBar(\n          title: Text('Todos'),\n        ),\n        body: ListView.builder(\n            itemCount: todos.length,\n            itemBuilder: (context, index) {\n              return ListTile(\n                  title: Text(todos[index].title),\n                  onTap: () {\n                    Navigator.push(\n                        context,\n                        MaterialPageRoute(\n                            builder: (context) => DetailScreen(\n                                  todo: todos[index],\n                                )));\n                  });\n            }));\n  }\n}\n\nclass DetailScreen extends StatelessWidget {\n  final Todo todo;\n  DetailScreen({Key key, @required this.todo}) : super(key: key);\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(todo.title),\n      ),\n      body: Padding(\n        padding: EdgeInsets.all(16.0),\n        child: Text(todo.description),\n      ),\n    );\n  }\n}\n```\n\n效果图：\n\n![sendDataToNewScreen](https://riverli.oss-cn-beijing.aliyuncs.com/image/1561275135.gif)\n\n### 参考资料\n\n[Swift Hero](https://github.com/HeroTransitions/Hero)\n\n[flutter-navigation](https://flutter.dev/docs/cookbook/navigation)","tags":["flutter"]},{"title":"启动优化-main前流程分析","url":"/2019/06/21/启动优化-main前流程分析/","content":"\n### 一些原理性知识\n\n### 启动流程分析\n\n### 启动流程优化\n\n","tags":["性能优化"]},{"title":"性能优化-耗时监控","url":"/2019/06/21/性能优化-耗时监控/","content":"\n### 使用Time Profiler进行耗时监控\n\n#### 原理\n\n#### 具体使用\n\n### 通过hook objc_msgSend方法获取方法的执行耗时\n\n#### 原理\n\n#### 具体使用\n\n","tags":["性能优化"]},{"title":"iOSApp启动流程以及优化","url":"/2019/06/21/iOSApp启动流程以及优化/","content":"\n### 启动流程\n\n![image-20190620181305956](https://riverli.oss-cn-beijing.aliyuncs.com/image/1561080736.png)\n\n我们将App启动分为三部分：\n\n1. 用户点击App到main函数开始执行。\n2. main函数开始执行到首屏数据加载完成。\n3. 首屏渲染完成后。\n\n我们需要分析这两个阶段App分别作了什么操作，针对这些操作我们可以进行怎么的优化。\n\n### 阶段一：用户点击App到main函数开始执行\n\n#### App做了什么\n\n- 加载可执行文件(App的.o文件的集合)\n- 加载动态链接库，进行rebase指针调整和bind符号绑定。\n- Objc 运行时的初始处理，包括Objc相关类的注册，categoray注册，selector唯一性检查等。\n- 初始化，包括了执行+load()方法、attribute((constructor))修饰的函数的调用，创建C++静态全局变量。\n\n#### 做什么优化\n\n总的来说，这个阶段可做的优化是**少做些事情**。具体如下：\n\n- 减少动态库加载。可将多个动态库合并成一个。\n- 减少加载启动后不会使用的类或者方法。\n- 尽量避免使用+load()方法，或使用+initlalize()方法替换掉。\n\n### 阶段二： main函数开始执行到首屏渲染完成\n\n这个阶段是指从main()函数执行开始，到appDelegate的didFinishLaunchingWithOptions方法里**首屏渲染相关方法**执行完成。\n\n#### App做了什么\n\n首页的业务代码都是要在这个阶段，也就是首屏渲染前执行的，主要有：\n\n- 首屏初始化所需配置文件的读写操作。\n- 首屏列表大数据的读取。\n- 首屏渲染的大量计算等。\n\n#### 做什么优化\n\n在这个阶段，开发者需要从功能上梳理出那些是首屏渲染必要的初始化功能，那些是只需要在对应的功能开始使用时才需要初始化的。梳理完成之后，将这些初始化功能分别放到合适的阶段进行。\n\n### 阶段三：首屏渲染完成后\n\n这个阶段是指didFinishLaunchingWithOptions方法里**首屏渲染相关方法**后面的所有方法，主要是非首屏其他业务模块的初始化、监听的注册、配置文件的读取等。\n\n#### App做了什么\n\n- 非首屏其他业务模块的初始化、监听的注册、配置文件的读取等。\n\n#### 做什么优化\n\n- 不要阻塞主线程。\n\n### 参考资料\n\n[wwdc2016-406](https://developer.apple.com/videos/play/wwdc2016/406/)","tags":["性能优化"]},{"title":"产品设计方案犹豫不决？试一下A/B测试","url":"/2019/05/08/产品设计方案犹豫不决？试一下A-B测试/","content":"\n### 什么是A/B测试 \n\n> AB测试是为Web或App界面或流程制作两个（A/B）或多个（A/B/n）版本，在同一时间维度，分别让组成成分相同（相似）的访客群组（目标人群）随机的访问这些版本，收集各群组的用户体验数据和业务数据，最后分析、评估出最好版本，正式采用。[百度百科] \n\n举例例子来说：我们正在做一个活动，通过文案引导用户点击按钮跳转到活动页。这时产品和老板分别给出了一套文案A和B。他们两个各自有理，作为程序员的你当然不能站在那看\"笑话\"，你要从技术的角度来平息这场争吵。那就可以引入A/B测试。 \n\n### A/B测试方案 \n\n- 纯前端控制A/B桶内用户数，将结果汇总到统计服务器上。 \n\n- 由后台控制A/B桶内用户数，结果汇总到后台。 \n\n这两种方案都有各自的有缺点，我比较支持第二种做法，因为可以灵活的控制A/B桶内用户数。 \n\n### A/B测试库[SkyLab](https://github.com/mattt/SkyLab) \n\n[SkyLab](https://github.com/mattt/SkyLab) 是iOS端的一个A/B、多元测试框架。我们看一下使用方法： \n\n**A/B测试** \n\n``` objective-c\n- (void)viewDidLoad { \n\t[super viewDidLoad]; \n\t[SkyLab abTestWithName:@\"Title\" A:^{ \n\t\tself.tipLabel.text = @\"我在使用方案A\"; \n\t} B:^{ \n\t\tself.tipLabel.text = @\"我在使用方案B\"; \n\t}]; \n}\n\n- (IBAction)resetPlanButton:(id)sender { \n\t[SkyLab resetTestNamed:@\"Title\"]; \n} \n```\n\n\n\n**多元测试 ：可能命中一个或多个**\n\n```objective-c\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    [SkyLab multivariateTestWithName:@\"MTitle\"\n                           variables:@{\n                                       @\"A\" : @(0.5), //数字表示命中机率\n                                       @\"B\" : @(0.5),\n                                       @\"C\" : @(0.5)\n                                       }\n                               block:^(NSSet *assignedVariables) {\n                                   NSString *text = @\"正在使用\";\n                                   if ([assignedVariables containsObject:@\"A\"]) {\n                                       text = [text stringByAppendingString:@\"A\"];\n                                   }\n                                   if ([assignedVariables containsObject:@\"B\"]) {\n                                       text = [text stringByAppendingString:@\"B\"];\n                                   }\n                                   if ([assignedVariables containsObject:@\"C\"]) {\n                                       text = [text stringByAppendingString:@\"C\"];\n                                   }\n                                   self.tipLabel.text = text;\n                               }];\n}\n\n- (IBAction)resetPlanButton:(id)sender {\n    [SkyLab resetTestNamed:@\"MTitle\"];\n}\n\n```\n\n\n\n**分割测试：只会命中一个**\n\n```objective-c\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    [SkyLab splitTestWithName:@\"STitle\"\n                   conditions:@{\n                                @\"A\" : @(0.5), //数字表示命中机率\n                                @\"B\" : @(0.5),\n                                @\"C\" : @(0.5)\n                                }\n                        block:^(id condition) {\n                            NSString *text = @\"正在使用\";\n                            if ([condition isEqualToString:@\"A\"]) {\n                                text = [text stringByAppendingString:@\"A\"];\n                            } else if ([condition isEqualToString:@\"B\"]) {\n                                text = [text stringByAppendingString:@\"B\"];\n                            } else if ([condition isEqualToString:@\"C\"]) {\n                                text = [text stringByAppendingString:@\"C\"];\n                            }\n                            self.tipLabel.text = text;\n                        }];\n}\n\n- (IBAction)resetPlanButton:(id)sender {\n    [SkyLab resetTestNamed:@\"STitle\"];\n}\n```\n\n\n\n","tags":["A/B测试 方案"]},{"title":"算法训练-LeeCode002两数相加","url":"/2019/05/06/算法训练-LeeCode002两数相加/","content":"\n### 题目描述\n\n> 给出两个 **非空** 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 **逆序** 的方式存储的，并且它们的每个节点只能存储 **一位** 数字。\n>\n> 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。\n>\n> 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例：**\n\n```C++\n输入：(2 -> 4 -> 3) + (5 -> 6 -> 4)\n输出：7 -> 0 -> 8\n原因：342 + 465 = 807\n```\n\n### 解法一：暴力计算\n\n该解法使用数字相加的方法进行计算，但该解法有一个致命的问题是整数溢出。所以，严格意义上说，这种方式是错误的。代码如下：\n\n```C++\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nint listNodeLength(ListNode *list) {\n    if (list == NULL || list->next == NULL)\n    {\n        return 0;\n    }\n    \n    int size = 0;\n    ListNode *tmpPoint = list;\n    while(tmpPoint->next != NULL) {\n        size++;\n        tmpPoint = tmpPoint->next;\n    }\n    return size;\n}\n\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int sum1 = getListSum(l1);\n        int sum2 = getListSum(l2);\n        int sum3 = sum1 + sum2;\n        \n        int sum3Length = 0;\n        int tmp = sum3;\n        while(tmp > 0) {\n            tmp = tmp/10;\n            sum3Length++;\n        }\n        \n        ListNode *head = NULL;\n        ListNode *tail = nullptr;\n        int m = sum3;\n        while(sum3Length > 0) {\n            int val = m%(10);\n            m = m / 10;\n            \n            ListNode *list = new ListNode(val);\n            if (head)\n            {\n                tail->next = list;\n                tail = list;\n            } else {\n                head = list;\n                tail = head;\n            }\n            sum3Length--;\n        }\n        return head;\n        \n    }\n    \n    int getListSum(ListNode *list) {\n        int length = listNodeLength(list);\n        \n        int sum = 0;\n        int index = 0;\n        ListNode *tmpPoint = list;\n        while(tmpPoint != NULL) {\n            sum += pow(10, length-index) * tmpPoint->val;\n            tmpPoint = tmpPoint->next;\n            index++;\n        }\n        \n        return sum;\n        \n    }\n};\n```\n\n### 解法二：按位计算\n\n该解法使用一个变量表示进位值。如下图，temp表示进位。将两个list长度改为一致，通过补0操作。\n\n![企业微信20190507011341.png](https://i.loli.net/2019/05/07/5cd11415332d4.png)\n\n具体代码如下：\n\n```c++\nstruct ListNode {\n    int val;\n    ListNode *next;\n    ListNode(int x) : val(x), next(NULL) {}\n};\n\nint listNodeLength(ListNode *list) {\n    if (list == NULL)\n    {\n        return 0;\n    }\n    \n    int size = 0;\n    ListNode *tmpPoint = list;\n    while(tmpPoint != NULL) {\n        size++;\n        tmpPoint = tmpPoint->next;\n    }\n    return size;\n}\n\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int l1Length = listNodeLength(l1);\n        int l2Length = listNodeLength(l2);\n        \n        int max = l1Length;\n        ListNode *maxListNode = l1;\n        int min = l2Length;\n        ListNode *minListNode = l2;\n        if (l1Length<l2Length)\n        {\n            max = l2Length;\n            maxListNode = l2;\n            \n            min = l1Length;\n            minListNode = l1;\n        }\n        \n        ListNode *minTail = minListNode;\n        ListNode *maxTail = maxListNode;\n        while (maxTail != NULL) {\n            if (minTail -> next == NULL) {\n                minTail->next = new ListNode(0);\n            }\n            maxTail = maxTail -> next;\n            minTail = minTail->next;\n        }\n        \n        int temp = 0;\n        ListNode* l1temp = minListNode;\n        ListNode* l2temp = maxListNode;\n        ListNode *result = NULL;\n        ListNode *resultTail = NULL;\n        for (int i = 0; i < max; ++i)\n        {\n            int sum = l1temp->val + l2temp->val + temp;\n            temp = sum/10;\n            int val = sum%10;\n            ListNode *node = new ListNode(val);\n            if (result == NULL)\n            {\n                result = node;\n                resultTail = result;\n            }\n            else\n            {\n                resultTail->next = node;\n                resultTail = node;\n            }\n            \n            l1temp = l1temp->next;\n            l2temp = l2temp->next;\n        }\n        \n        if (temp > 0) {\n            resultTail->next = new ListNode(temp);\n        }\n        return result;\n    }\n};\n```\n\n### 源码\n\n你可以通过点击这里获取源代码：[LeeCodeTrain](https://github.com/riverlj/LeeCodeTrain)\n\n","tags":["LeeCode 算法"]},{"title":"算法训练-LeeCode001两数之和","url":"/2019/05/06/算法训练-LeeCode001两数之和/","content":"\n> 给定一个整数数组 `nums` 和一个目标值 `target`，请你在该数组中找出和为目标值的那 **两个** 整数，并返回他们的数组下标。\n>\n> 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。\n\n示例：\n\n> 给定 nums = [2, 7, 11, 15], target = 9\n>\n> 因为 nums[0] + nums[1] = 2 + 7 = 9\n> 所以返回 [0, 1]\n\n### 解法一 ：暴力运算\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n    \tvector<int> result;\n\t\tif (nums.size() < 2)\n\t\t{\n\t\t\treturn result;\t\n\t\t}\n\n\t\tfor (int i=0; i<nums.size(); i++) \n\t\t{\n\t\t\tbool find = false;\n\t\t\tfor (int j = i+1; j < nums.size(); ++j)\n\t\t\t{\n\t\t\t\tif (nums[i]+nums[j] == target)\n\t\t\t\t{\n\t\t\t\t\tresult.push_back(i);\n\t\t\t\t\tresult.push_back(j);\n\t\t\t\t\tfind = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (find)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t    }\n};\n```\n\n### 解法二 ：转map\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n    \tvector<int> result;\n\t\tif (nums.size() < 2)\n\t\t{\n\t\t\treturn result;\t\n\t\t}\n\n\t\tmap<int, int> mapNums;\n\t\tfor (int i = 0; i < nums.size(); ++i)\n\t\t{\n\t\t\tint num = nums[i];\n\t\t\tmapNums[num] = i;\n\t\t}\n\n\t\t// map<int,int>::iterator it = mapNums.begin();\n\t\t// while(it != mapNums.end())\n\t\t// {\n\t\t//     cout << it->first << \" \" << it->second << endl;\n\t\t//     it ++;         \n\t\t// }\n\n\t\tfor (int i = 0; i < nums.size(); ++i)\n\t\t{\n\t\t\tint otherValue = target - nums[i];\n\t\t\tmap<int, int>:: iterator it = mapNums.find(otherValue);\n\t\t\tif (it != mapNums.end() && it->second != i)\n\t\t\t{\n\t\t\t\tresult.push_back(i);\n\t\t\t\tresult.push_back(mapNums[otherValue]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t    }\n};\n```\n\n### 解法三：转map减少循环次数\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n    \tvector<int> result;\n\t\tif (nums.size() < 2)\n\t\t{\n\t\t\treturn result;\t\n\t\t}\n\n\t\tmap<int, int> mapNums;\n\t\tfor (int i = 0; i < nums.size(); ++i)\n\t\t{\n\t\t\tint otherValue = target - nums[i];\n\t\t\tmap<int, int>:: iterator it = mapNums.find(otherValue);\n\t\t\tif (it != mapNums.end() && it->second != i)\n\t\t\t{\n\t\t\t\tresult.push_back(mapNums[otherValue]);\n\t\t\t\tresult.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint num = nums[i];\n\t\t\tmapNums[num] = i;\n\n\n\t\t}\n\n\t\treturn result;\n\t    }\n};\n```\n\n### 解法四：继续优化\n\n```c++\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n\n    \tvector<int> result;\n    \tmap<int, int>:: iterator it;\n\t\tmap<int, int> mapNums;\n\t\tfor (int i = 0; i < nums.size(); ++i)\n\t\t{\n\t\t\tmapNums.insert(make_pair(nums[i], i));\n\t\t\tit = mapNums.find(target - nums[i]);\n\t\t\tif (it != mapNums.end() && it->second != i)\n\t\t\t{\n\t\t\t\tresult.push_back(i);\n\t\t\t\tresult.push_back(it->second);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t    }\n};\n```\n\n","tags":["LeeCode 算法"]},{"title":"iOS多线程编程三：Operation和OperationQueue","url":"/2018/07/31/iOS多线程编程三：Operation和OperationQueue/","content":"### 概述\n\n本文是多线程的第三篇文章，主要讲解Operation和OperationQueue。看资料的时候发现了一篇特别好的教程，随性就翻译一下，权当自己做个总结。本文主要内容翻译自`raywenderlich`的`operation and operationqueue tutorial in swift`。原文链接点[这里](https://www.raywenderlich.com/190008/operation-and-operationqueue-tutorial-in-swift)。\n\n不管是在Mac还是iOS系统上，当用户使用你的app点击按钮或者编辑文本的时候突然你的app卡死，界面变得无法响应，这对用户来讲是非常糟糕的体验。 在Mac系统上用户不得不盯着彩色的加载框等待恢复。在iOS系统上连加载框都看不到。用户希望在他们触摸屏幕之后应用程序能立即做出响应。卡顿的app让用户感到这个app很笨重，反应太慢。这会造成用户在AppStore中给应用差评。\n<!--more -->\n保持app的流畅响应说起来容易做起来可是相当不容易。一旦你的app需要处理多个任务，事情很快变得复杂起来。主线程的run loop循环中没有足够的时间来处理繁重的任务，同时还要响应用户的UI操作。\n\n这种情况下，开发者该如何应对呢？解决办法就是通过多并行的手段将任务从主线程中剥离。并行的意思是你的应用程序同时执行多个工作流(或者多个线程)。这使得在执行任务的同时用户界面同时能够保持响应。\n\n`Operation`和`OPerationQueue`这两个类是iOS系统中并发执行任务的一种方式。本教程就是讲述的就是如何使用它们。我们将以一个没用并发的例子开始，它会非常的卡顿，然后你将逐步加入并发操作，使之变得流畅。\n\n### 开始\n\n我们的例子是展示一个滚动的图片列表，图片来自于网络，然后下载图片之后需要对其过滤，然后添加到表格上显示。应用的模型如下：\n\n![应用模型](https://user-gold-cdn.xitu.io/2018/7/31/164f01893734517d?w=650&h=850&f=jpeg&s=65746)\n\n### 第一次尝试\n\n点击这里[下载最初的项目](https://pan.baidu.com/s/1qVI6lgJ3fNxAU-kxJw2YmA)，这是该教程项目的第一个版本。\n\n> **注意：** 所有的图片都来自[stock.xchng](http://sxc.hu/) 数据源中有些的图片名字被故意错误的命名，这是为了模拟图片下载失败的场景。\n\n运行该项目，你讲看到滚动的图片列表如下，滑动该列表，是不是很不流畅。(国内需要给手机翻墙或者挂代理)。\n\n![运行效果](https://user-gold-cdn.xitu.io/2018/7/31/164f018937345f48?w=640&h=960&f=jpeg&s=149298)\n\n所有的响应代码都在**ListViewController.swift**这个类中，大部分在**tableView(_:cellForRowAtIndexPath:**里。\n\n查看该方法里的代码，可以发现这里主要做了两件事：\n\n- 从网络上下载图片。\n- 使用Core Image 过滤图片。\n\n还有，第一次加载的时候，你需要从网络上获取所有图片的url。\n\n```\nlazy var photos = NSDictionary(contentsOf:dataSourceURL)!\n```\n\n所有这些工作都发生在应用程序的主线程。由于主线程还担任着界面的交互，过多的在主线程上加载图片，过滤图片会给主线程造成压力，这必然会牺牲应用的响应流畅度。你可以在Xcode的debug 导航条上查看CPU的工作情况。\n\n![cpu执行情况](https://user-gold-cdn.xitu.io/2018/7/31/164f0189372ed870?w=690&h=355&f=jpeg&s=53353)\n\n\n\n从图中我们可以看到，大部分的任务消耗在thread1, 它是应用程序的主线程。\n\n接下来我们来优化用户体验。\n\n### 任务，线程，进程\n\n在进行下一步之前，有几个概念你需要了解一下：\n\n- 任务：你需要处理的一个简单的，独立的工作。\n- 线程：由操作系统提供的一种机制，可以使在一个app内让多个操作同时执行。\n- 进程：一个可执行的代码块，由多个线程组成。\n\n> 在iOS和MacOS系统上，线程的功能是由POSIX线程API(或者pthreads)提供的，它们是操作系统的一部分。它们是很底层的，使用这些ÅPI编写代码及易出错，更糟糕的是由它们引发的错误非常难排查\n>\n> Foundation框架包含了一个Thread的类，它是线程相对容易使用，但使用Thread管理多线程仍然令人头疼。Operation 和 OperationQueue 是更高层次的API，使用它们处理多线程非常的方便了很多。\n\n下面展示了进程、线程、任务之间的关系。\n\n![进程、线程、任务之间的关系](https://user-gold-cdn.xitu.io/2018/7/31/164f01893749372c?w=600&h=131&f=jpeg&s=22420)\n\n如上图所示，一个进程和包含多个线程，同一时刻每个线程可以同时执行多个任务。\n\n在上图中，Thread2 执行读取文件的操作，同时Thread1执行用户交互相关的代码。这和iOS代码结构十分相似：主线程应该执行和用户交互相关的操作，其他线程应该执行耗时操作，如读取文件，访问网络等等。\n\n### Operation 和 GCD的比较\n\n你可能听说过GCD，简而言之，GCD由语言功能，运行时库和系统增强功能组成，可提供系统和全面的改进，以支持iOS和macOS中多核硬件的并发性。如果你想学习GCD可以参考[GCD Tutorial](https://www.raywenderlich.com/?p=148513)。\n\n**Operation**和**OperationQueue** 是构建在GCD之上的，通常来说，苹果建议使用最高级别的API来开发，必要的时候再使用低级API。\n\n下面是这两套API的简单比较，以便帮助你决定什么时间什么地方使用GCD或者OPeration:\n\n- GCD 是一种轻量级的方式，用以表示即将并行执行的工作单元。你不用负责这些工作单元的执行，操作系统替你负责工作单元的调度。添加block之间的依赖是一件令人头疼的事，取消或者挂起一个block需要你编写额外的代码。\n\n- GCD操作增加了一些额外的开销，但您可以在各种操作之间添加依赖关系并重新使用，取消或暂停它们。\n\n这篇教程使用Operation，因为你处理的是tableView，出于性能的原因，你需要在图片离开屏幕的时候取消图片的下载任务。即使这些操作实在后台线程中执行的，但如果大量的操作在队列中等待，性能依然会很糟糕。\n\n### 重新定义App模型\n\n是时候重新定义最初的没有额外线程的模型了。如果你仔细观察了最初的模型，你会发现它有三个地方可以提高。将这三个地方放在单独的线程中，主线程就可以安心的响应用户界面了。\n\n![重新定义模型](https://user-gold-cdn.xitu.io/2018/7/31/164f0189375d0716?w=650&h=850&f=jpeg&s=101075)\n\n为了摆脱App的性能瓶颈，你需要一个线程来专门响应用户操作，一个线程来数据源和图片，一个线程来执行图片过滤。在新的模型中，App从主线程中启动，并加载一个空的tableView，同时，app开启一个线程来加载数据源。\n\n一旦数据源下载成功，你讲告知tableView刷新表格，刷新表格的操作必须在主线程中执行，因为它涉及到界面操作。这时，tableView知道了它拥有多少个行和需要展示的图片的URL，但它还没有真实的图片，如果这时你立即开始下载所有的图片，这将是非常糟糕的，因为你不需要同时展示所有的图片。\n\n那么，怎么做会好一点呢？\n\n 一个比较好的方式是仅仅下载那些屏幕内可见的cell的图片。因此你的代码应首先询问tableView那些行是可见的，然后再开启下载任务。与之相似，图片过滤操作也不能等待图片完全下载之后开始。因此，应用程序不应启动图像过滤任务，直到有未经过滤的图像等待处理。\n\n为了使app看起来更加可响应，一旦图片下载之后就会展示它。然后开始图片过滤，然后将过滤后的图片显示在界面上。下图展示了新模型的调度控制情况：\n\n![控制流程](https://user-gold-cdn.xitu.io/2018/7/31/164f0189375975b6?w=650&h=250&f=jpeg&s=38480) \n\n为了实现这些目标，你需要跟踪image的状态，下载中，已下载，已过滤。你也需要跟踪每个operation的状态和类型，以便于你在用户滚动的时候可以取消，暂停或者恢复它。\n\n好啦，现在开始编码！\n\n打开Xcode，新建一个Swift文件，叫做`PhotoOperations.swift` ，添加如下代码：\n\n```swift\nimport UIKit\n\n// This enum contains all the possible states a photo record can be in\nenum PhotoRecordState {\n  case new, downloaded, filtered, failed\n}\n\nclass PhotoRecord {\n  let name: String\n  let url: URL\n  var state = PhotoRecordState.new\n  var image = UIImage(named: \"Placeholder\")\n  \n  init(name:String, url:URL) {\n    self.name = name\n    self.url = url\n  }\n}\n```\n\n这个类代表了app内展示的每个图片和它当前的状态，默认是 .new，图片默认情况下是一个占位图。\n\n为了追踪每个opration的状态，你需要另一个类，在`photoOperations.swift` 的末尾添加如下类：\n\n```Swift\nclass PendingOperations {\n  lazy var downloadsInProgress: [IndexPath: Operation] = [:]\n  lazy var downloadQueue: OperationQueue = {\n    var queue = OperationQueue()\n    queue.name = \"Download queue\"\n    queue.maxConcurrentOperationCount = 1\n    return queue\n  }()\n  \n  lazy var filtrationsInProgress: [IndexPath: Operation] = [:]\n  lazy var filtrationQueue: OperationQueue = {\n    var queue = OperationQueue()\n    queue.name = \"Image Filtration queue\"\n    queue.maxConcurrentOperationCount = 1\n    return queue\n  }()\n}\n```\n\n此类包含两个字典，用于跟踪表中每行的活动和挂起下载和过滤操作，以及每种操作类型的操作队列。\n\n所有的操作都是懒加载，他们到第一次访问的时候才初始化，这会提升app的性能。\n\n如你所见，创建一个OperationQueue非常简单，对queue进行命名有助于你调试代码。最大并发操作数量设置为1是为了教学所有，为了让你看到操作被一个接一个的完成。您可以将此部分保留，并允许队列决定它可以同时处理多少操作 - 这将进一步提高性能。\n\n 队列如何决定一次可以运行多少个操作？这是个好问题！这取决于硬件。默认情况下，OperationQueue会在幕后进行一些计算，确定它运行的特定平台的最佳值，并启动尽可能多的线程。\n\n考虑如下情况：假设系统处于空闲状态，并且有大量可用资源。在这种情况下，队列可以同时启动八个线程。下次运行程序时，系统可能正忙于其他消耗资源操作。这次，队列可能只启动两个同时发生的线程。因为在此应用程序中设置了最大并发操作计数，所以一次只能执行一个操作。\n\n> 你可能会好奇为什么要跟踪所有活动和挂起的oprations呢？queue有一个operations方法，这个方法返回operation的数组，为什么不利用他呢？ 在这个项目中，因为他的效率并不高。你需要跟踪那个Operation和tableView的row相关，这将涉及到每次使用的时候遍历数组。但把他们存储在一个字典里，并使用Indexpath作为key，意味着查询的时候将更加快和高效。\n\n是时候关心下载和过滤的操作了，将下面代码添加到`PhotoOperations.swift` 的尾部。\n\n```swift\nclass ImageDownloader: Operation {\n  //1\n  let photoRecord: PhotoRecord\n  \n  //2\n  init(_ photoRecord: PhotoRecord) {\n    self.photoRecord = photoRecord\n  }\n  \n  //3\n  override func main() {\n    //4\n    if isCancelled {\n      return\n    }\n\n    //5\n    guard let imageData = try? Data(contentsOf: photoRecord.url) else { return }\n    \n    //6\n    if isCancelled {\n      return\n    }\n    \n    //7\n    if !imageData.isEmpty {\n      photoRecord.image = UIImage(data:imageData)\n      photoRecord.state = .downloaded\n    } else {\n      photoRecord.state = .failed\n      photoRecord.image = UIImage(named: \"Failed\")\n    }\n  }\n}\n```\n\nOperation是一个抽象类，专为子类化而设计。每个子类代表一个特定的任务，如前面的图所示。\n\n以下是上述代码中每个编号注释的内容：\n\n1. 添加一个常量，引用与operation相关的PhotoRecord。\n2. 创建初始化方法，并传入PhotoRecord。\n3. main() 方法是重写自operation, 是真正执行任务的地方。\n4. 在开始之前检查是否处于取消状态。在尝试耗时的操作之前，应定期检查是否处于取消状态。\n5. 下载图片数据。\n6. 重新检测是否处于取消状态。\n7. 如果图片成功下载，创建图片并添加到record中，然后设置状态。如果下载失败，标记record为失败，并设置相应的图片。\n\n下一步，你需要创建另一个operation 来处理图片过滤。把下面的代码添加到`PhotoOperations.swift`的尾部。\n\n```swift\nclass ImageFiltration: Operation {\n  let photoRecord: PhotoRecord\n  \n  init(_ photoRecord: PhotoRecord) {\n    self.photoRecord = photoRecord\n  }\n  \n  override func main () {\n    if isCancelled {\n        return\n    }\n      \n    guard self.photoRecord.state == .downloaded else {\n      return\n    }\n      \n    if let image = photoRecord.image, \n       let filteredImage = applySepiaFilter(image) {\n      photoRecord.image = filteredImage\n      photoRecord.state = .filtered\n    }\n  }\n}\n```\n\n 这看起来与下载操作非常相似，只是使用了图像过滤操作（使用尚未实现的方法，因此编译器错误）替换了下载操作。\n\n在ImageFiltration类中添加过滤方法\n\n```swift\nfunc applySepiaFilter(_ image: UIImage) -> UIImage? {\n  guard let data = UIImagePNGRepresentation(image) else { return nil }\n  let inputImage = CIImage(data: data)\n      \n  if isCancelled {\n    return nil\n  }\n      \n  let context = CIContext(options: nil)\n      \n  guard let filter = CIFilter(name: \"CISepiaTone\") else { return nil }\n  filter.setValue(inputImage, forKey: kCIInputImageKey)\n  filter.setValue(0.8, forKey: \"inputIntensity\")\n      \n  if isCancelled {\n    return nil\n  }\n      \n  guard \n    let outputImage = filter.outputImage,\n    let outImage = context.createCGImage(outputImage, from: outputImage.extent) \n  else {\n    return nil\n  }\n\n  return UIImage(cgImage: outImage)\n}\n```\n\n这个方法和之前ListViewController中提供的过滤方法基本一致，移到这里是为了让其可以在operation中执行。同样的你需要频繁的检查operation的是否处于取消状态。一旦你的过滤执行完毕，需要重置record中的值。\n\n到这里我们已经有了所有的工具和方法来在后台处理任务。现在，我们回到viewcontroller来修改代码以提高性能。\n\n切换到ListViewController.swift文件，删除lazy var photos 属性，添加如下代码：\n\n```swift\nvar photos: [PhotoRecord] = []\nlet pendingOperations = PendingOperations()\n```\n\n这两个属相持有了PhotoRecord组成的数组和PendingOperations对象来管理operations。\n\n添加一个新的方法来下载photos数组的值\n\n```swift\nfunc fetchPhotoDetails() {\n  let request = URLRequest(url: dataSourceURL)\n  UIApplication.shared.isNetworkActivityIndicatorVisible = true\n\n  // 1\n  let task = URLSession(configuration: .default).dataTask(with: request) { data, response, error in\n\n    // 2\n    let alertController = UIAlertController(title: \"Oops!\",\n                                            message: \"There was an error fetching photo details.\",\n                                            preferredStyle: .alert)\n    let okAction = UIAlertAction(title: \"OK\", style: .default)\n    alertController.addAction(okAction)\n\n    if let data = data {\n      do {\n        // 3\n        let datasourceDictionary =\n          try PropertyListSerialization.propertyList(from: data,\n                                                     options: [],\n                                                     format: nil) as! [String: String]\n\n        // 4\n        for (name, value) in datasourceDictionary {\n          let url = URL(string: value)\n          if let url = url {\n            let photoRecord = PhotoRecord(name: name, url: url)\n            self.photos.append(photoRecord)\n          }\n        }\n\n        // 5\n        DispatchQueue.main.async {\n          UIApplication.shared.isNetworkActivityIndicatorVisible = false\n          self.tableView.reloadData()\n        }\n        // 6\n      } catch {\n        DispatchQueue.main.async {\n          self.present(alertController, animated: true, completion: nil)\n        }\n      }\n    }\n\n    // 6\n    if error != nil {\n      DispatchQueue.main.async {\n        UIApplication.shared.isNetworkActivityIndicatorVisible = false\n        self.present(alertController, animated: true, completion: nil)\n      }\n    }\n  }\n  // 7\n  task.resume()\n}\n```\n\n1. 创建URLSession任务在后台下载image列表。\n2. 配置UIAlertController，在错误的时候使用它。\n3. 如果请求成功，请从属性列表中创建字典。字典使用图像名称作为键，其URL作为值。\n4. 从字典构建PhotoRecord对象数组。\n5. 返回主线程以重新加载表视图并显示图像。\n6. 发生错误时显示警告控制器。请记住，URLSession任务在后台线程上运行，并且必须在主线程中显示屏幕上的任何消息。\n7. 运行下载任务。\n\n在viewDidLoad()方法中调用这个方法：\n\n```swift\nfetchPhotoDetails()\n```\n\n下一步，找到tableView(_:cellForRowAtIndexPath:)方法，用以下代码替换它\n\n```swift\noverride func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {\n  let cell = tableView.dequeueReusableCell(withIdentifier: \"CellIdentifier\", for: indexPath)\n  \n  //1\n  if cell.accessoryView == nil {\n    let indicator = UIActivityIndicatorView(activityIndicatorStyle: .gray)\n    cell.accessoryView = indicator\n  }\n  let indicator = cell.accessoryView as! UIActivityIndicatorView\n  \n  //2\n  let photoDetails = photos[indexPath.row]\n  \n  //3\n  cell.textLabel?.text = photoDetails.name\n  cell.imageView?.image = photoDetails.image\n  \n  //4\n  switch (photoDetails.state) {\n  case .filtered:\n    indicator.stopAnimating()\n  case .failed:\n    indicator.stopAnimating()\n    cell.textLabel?.text = \"Failed to load\"\n  case .new, .downloaded:\n    indicator.startAnimating()\n    startOperations(for: photoDetails, at: indexPath)\n  }\n  \n  return cell\n}\n```\n\n1. 创建UIActivityIndicatorView并将其设置为单元的附件视图， 为提供反馈。\n2. 根据indexpath从数据源中取出PhotoRecord。\n3. 单元格的文本标签（几乎）始终相同，PhotoRecord的图片在状态变更后设置，因此无论record的状态如何，您都可以在此处设置它们。\n4. 检查Record。根据需要设置活动指示符和文本，然后启动操作（尚未实现）。\n\n实现启动操作方法\n\n```swift\nfunc startOperations(for photoRecord: PhotoRecord, at indexPath: IndexPath) {\n  switch (photoRecord.state) {\n  case .new:\n    startDownload(for: photoRecord, at: indexPath)\n  case .downloaded:\n    startFiltration(for: photoRecord, at: indexPath)\n  default:\n    NSLog(\"do nothing\")\n  }\n}\n```\n\n在这里，您传入PhotoRecord的实例及其索引路径。根据照片记录的状态，您可以启动下载或过滤操作。\n\n> 下载和过滤图像的方法是分开实现的。因为有可能在下载图像时用户可以滚动，所以你并不需要应用图像过滤器。下次用户来到同一行时，您无需重新下载图像;你只需要应用图像过滤器！\n\n现在，您需要实现在上面的方法中调用的方法。前面我们创建了一个自定义类PendingOperations来跟踪操作; 现在你真的开始使用它了！将以下方法添加到类中：\n\n```swift\nfunc startDownload(for photoRecord: PhotoRecord, at indexPath: IndexPath) {\n  //1\n  guard pendingOperations.downloadsInProgress[indexPath] == nil else {\n    return\n  }\n      \n  //2\n  let downloader = ImageDownloader(photoRecord)\n  \n  //3\n  downloader.completionBlock = {\n    if downloader.isCancelled {\n      return\n    }\n\n    DispatchQueue.main.async {\n      self.pendingOperations.downloadsInProgress.removeValue(forKey: indexPath)\n      self.tableView.reloadRows(at: [indexPath], with: .fade)\n    }\n  }\n  \n  //4\n  pendingOperations.downloadsInProgress[indexPath] = downloader\n  \n  //5\n  pendingOperations.downloadQueue.addOperation(downloader)\n}\n    \nfunc startFiltration(for photoRecord: PhotoRecord, at indexPath: IndexPath) {\n  guard pendingOperations.filtrationsInProgress[indexPath] == nil else {\n      return\n  }\n      \n  let filterer = ImageFiltration(photoRecord)\n  filterer.completionBlock = {\n    if filterer.isCancelled {\n      return\n    }\n    \n    DispatchQueue.main.async {\n      self.pendingOperations.filtrationsInProgress.removeValue(forKey: indexPath)\n      self.tableView.reloadRows(at: [indexPath], with: .fade)\n    }\n  }\n  \n  pendingOperations.filtrationsInProgress[indexPath] = filterer\n  pendingOperations.filtrationQueue.addOperation(filterer)\n}\n```\n\n1. 从downloadsInProgress中查找指定的IndexPath中是否有operation，如果有就返回。\n2. 如果没有就创建ImageDownloader。\n3. 添加一个完成的block，它将在operation执行完毕之后执行。这是让您的应用程序的其余部分知道操作已完成的好地方。要注意如果操作被取消也会执行完成块，因此您必须在执行任何操作之前检查此属性。你也无法保证调用完成块的线程，因此需要使用GCD触发主线程上表视图的重新加载。\n4. 将operation添加到downloadsInProgress以帮助跟踪。\n5. 将操作添加到下载队列。这是开始执行任务的方式。一旦你将operation添加到队列，队列开始处理任务的调度。\n\nstartFiltration 方法遵循同样的原则，只是使用了ImageFiltration和filtrationsInProgress来追踪operation。\n\n到这里，我们已经完成了。运行该项目，查看效果。你滚动浏览表格视图，应用程序不再停止并开始下载图像并在它们变得可见时对其进行过滤。\n\n![效果](https://user-gold-cdn.xitu.io/2018/7/31/164f018a4c8bf5d3?w=640&h=960&f=jpeg&s=52057)\n\n是不是很酷？你可以看到一点点努力可以大大提高您的应用程序响应速度 - 并为用户带来更多乐趣！\n\n### 微调\n\n你在本教程中已经走了很长的路！你的小项目具有响应性，并且与原始版本相比有很多改进。但是，仍有一些小细节需要处理。\n\n你可能已经注意到，当你在表格视图中滚动时，这些屏幕外单元格仍处于下载和过滤的过程中。如果您快速滚动，应用程序将忙于下载并过滤列表中更靠后的单元格中的图像，即使它们不可见。理想情况下，应用程序应取消对屏幕外单元格的过滤，并优先显示当前显示的单元格。\n\n你可以在你的代码中添加取消规则，来进一步优化。\n\n打开 ListViewController.swift 找tableView(_:cellForRowAtIndexPath:) 方法，在调用 startOperationsForPhotoRecord 方法的地方添加判断\n\n```swift\nif !tableView.isDragging && !tableView.isDecelerating {\n  startOperations(for: photoDetails, at: indexPath)\n}\n```\n\n只有在表视图不滚动时，才能告诉表视图启动操作。这些实际上是UIScrollView的属性，因为UITableView是UIScrollView的子类，所以表视图会自动继承这些属性。\n\n 接下来，将以下UIScrollView委托方法的实现添加到类中:\n\n```swift\noverride func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {\n  //1\n  suspendAllOperations()\n}\n\noverride func scrollViewDidEndDragging(_ scrollView: UIScrollView, willDecelerate decelerate: Bool) {\n  // 2\n  if !decelerate {\n    loadImagesForOnscreenCells()\n    resumeAllOperations()\n  }\n}\n\noverride func scrollViewDidEndDecelerating(_ scrollView: UIScrollView) {\n  // 3\n  loadImagesForOnscreenCells()\n  resumeAllOperations()\n}\n```\n\n快速浏览上面的代码显示以下内容：\n\n1. 在用户开始滚动时，你将希望暂停所有操作并查看用户想要查看的内容。您将在稍后实现suspendAllOperations。\n2. 如果decelerate的值为false，则表示用户停止拖动表视图。因此，你希望恢复暂停操作，取消屏幕外单元格的操作，以及启动屏幕单元格的操作。之后实现loadImagesForOnscreenCells和resumeAllOperations。\n3. 此委托方法告诉你表视图停止滚动，因此需要执行与操作2相同的操作。\n\n接下来，将下面方法添加到ListViewController中。\n\n```Swift\nfunc suspendAllOperations() {\n  pendingOperations.downloadQueue.isSuspended = true\n  pendingOperations.filtrationQueue.isSuspended = true\n}\n\nfunc resumeAllOperations() {\n  pendingOperations.downloadQueue.isSuspended = false\n  pendingOperations.filtrationQueue.isSuspended = false\n}\n\nfunc loadImagesForOnscreenCells() {\n  //1\n  if let pathsArray = tableView.indexPathsForVisibleRows {\n    //2\n    var allPendingOperations = Set(pendingOperations.downloadsInProgress.keys)\n    allPendingOperations.formUnion(pendingOperations.filtrationsInProgress.keys)\n      \n    //3\n    var toBeCancelled = allPendingOperations\n    let visiblePaths = Set(pathsArray)\n    toBeCancelled.subtract(visiblePaths)\n      \n    //4\n    var toBeStarted = visiblePaths\n    toBeStarted.subtract(allPendingOperations)\n      \n    // 5\n    for indexPath in toBeCancelled {\n      if let pendingDownload = pendingOperations.downloadsInProgress[indexPath] {\n        pendingDownload.cancel()\n      }\n      pendingOperations.downloadsInProgress.removeValue(forKey: indexPath)\n      if let pendingFiltration = pendingOperations.filtrationsInProgress[indexPath] {\n        pendingFiltration.cancel()\n      }\n      pendingOperations.filtrationsInProgress.removeValue(forKey: indexPath)\n    }\n      \n    // 6\n    for indexPath in toBeStarted {\n      let recordToProcess = photos[indexPath.row]\n      startOperations(for: recordToProcess, at: indexPath)\n    }\n  }\n}\n```\n\n`suspendAllOperations()` and `resumeAllOperations()` 实现起来非常简单，OperationQueue可以通过将suspended属性设置为true来挂起queque里面的所有的操作。\n\nloadImagesForOnscreenCells() 有一点复杂。\n\n1. 从包含表视图中所有当前可见行的索引路径的数组开始。\n2. 过组合正在进行的所有下载和正在进行的所有过滤器，构建一组所有待处理操作。\n3. 构造一组包含要取消的操作的索引路径。从所有操作开始，然后删除可见行的索引路径。这将使一组操作涉及屏幕外行。\n4. 构造一组需要启动其操作的索引路径。从索引路径开始所有可见行，然后删除操作已挂起的那些行。\n5. 循环访问要取消的那些，取消它们，并从PendingOperations中删除它们的引用。\n6. 遍历那些要启动的，并为每个调用startOperations（for：at :)。\n\n运行应用，这是一个响应更快，资源管理更好的应用程序。\n\n![运行效果](https://user-gold-cdn.xitu.io/2018/7/31/164f018a4f3f78e4?w=690&h=345&f=jpeg&s=64383)\n\n 请注意，当您完成滚动表视图时，可见行上的图像将立即开始处理。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["多线程"]},{"title":"设计模式：原型模式","url":"/2018/07/30/设计模式：原型模式/","content":"\n\n### 概述\n\n我们知道设计模式方面的知识是一个初中级工程师进阶高级工程师过程中一道无法跨越的屏障，学好它并将它应用到自己的项目中是一件充满乐趣和成就感的事情。本文将讲述设计模式中的原型模式，通过阅读本文你将收获如下内容：\n\n- 什么是原型模式以及它的作用。\n- 什么时间使用原型模式。\n- Objective-C中深拷贝和浅拷贝\n- 原型模式的具体实践。\n\n<!--more-->\n下面我们分条讲述。\n\n### 原型模式及其作用\n\n![原型模式](http://ww1.sinaimg.cn/large/d3681d85ly1ftqhn1j59aj20g70b13yn.jpg)\n\n如上图所示，原型模式是指，一个抽象类 `Prototype` 具有一个`clone` 方法，其实现类`ConcretePrototype1`、`ConcretePrototype2` 实现各自的`clone`方法，在使用的时候，调用Prototype的clone方法可以clone任意实现类。其作用就是快速创建一个新的对象。请看如下代码：\n\n```\nPrototype *type = [[ConcretePrototype1 alloc] init];\n//(1)对type所持有的变量进行赋值。\ntype.a = \ntype.b = \n//(2)保存type的现有状态\n[array addObject:type];\n\n//(3)继续变更type的信息。\ntype.a = \ntype.b =\n```\n\n在上诉代码中，在步骤(2)中我们需要暂存一下当前type的状态，以便后续做比较或者其他用途。按照上面的代码是无法实现我们的需求的，因为把type加到数组之后，之后type的值依然再改变。为了不然type的值变化，我们可能这样做：\n\n```\nPrototype *type = [[ConcretePrototype1 alloc] init];\n//(1)对type所持有的变量进行赋值。\ntype.a = \ntype.b = \n\n//(2)保存type的现有状态\nPrototype *tempType = [[ConcretePrototype1 alloc] init];\ntempType.a = type.a\ntempType.b = type.b\n[array addObject:tempType];\n\n//(3)继续变更type的信息。\ntype.a = \ntype.b =\n```\n\n想一想，你是否写过这样的代码？这样的代码有什么不好呢？\n\n1. 代码冗余，如果需要多次保存状态，可能需要写多个这样的赋值逻辑，当然，你可以把它抽出来作为一个单独的函数。\n2. 如果type对象的属性中包含了多个其他对象，那么简单的赋值操作并不能保存这些对象的状态，还需要去创建这些对象，并拷贝其内部属性，这是相当繁琐的工程。\n\n看到这里你可能会想，我根本不会这么做，我会使用NSObject提供的copy方法，实现NSCopying 协议进行复制。你的想法非常赞，其实NSCopying就是Cocoa框架提供的一种原型模式，在讲解之前，我们先说一下，Objective-C的浅拷贝和深拷贝。\n\n\n### 何时使用原型模式\n\n- 需要创建的对象应独立于其类型与创建方式。\n- 要实例化的类是在运行时决定的。\n- 不想要与产品层次相对应的工厂层次。\n- 不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便。\n- 类不容易创建，比如每个组件可把其他组件作为子节点的组合对象。复制已有的组合对象并对副本进行修改会更加容易。\n- 从功能的角度来讲，不管什么对象，只要复制自身比手工实例化要好，都可以是原型对象。\n\n在以下两种特别常见的情形，我们会考虑使用此模式：\n\n- 有很多相关的类，其行为略有不同，而且主要差异在于内部属性，如名称，图像等。\n- 需要使用组合(树型)对象作为其他东西的基础。例如，使用组合对象作为组件来构建另一个组合对象。\n\n### 浅拷贝和深拷贝\n\n我们知道，OC中的变量引用有值引用和指针引用。对于值引用而言，没有深拷贝和浅拷贝的区分，区别在于指针引用。我们先看浅拷贝模型。\n\n![浅拷贝](http://ww1.sinaimg.cn/large/d3681d85ly1ftqopdkxv8j20fg0dyq3b.jpg)\n\n深拷贝\n\n![深拷贝](http://ww1.sinaimg.cn/large/d3681d85ly1ftqoputfjxj20fi0e9jrq.jpg)\n\n由上面两个模型可以看出深拷贝是将内存中的资源也进行了一份拷贝，而浅拷贝只是内存资源指针的拷贝。\n\n\n### 原型模式的实践\n\n填写表单使我们在我们生活中经常遇到，我们要填很多表单，比如说上学要填报名表，上班要填职位表等等，有时候我们填了一般忘记了关键信息或者有其他重要的事要先处理，我们需要先把现有表单信息保存下来，等有时间了再拿出来继续填写。\n\n首先我们需要一个表单协议\n\n```\n@protocol Form <NSObject, NSCopying>\n@property (copy, nonatomic) NSString *name;\n@property (copy, nonatomic) NSString *address;\n@property (strong, nonatomic) NSMutableArray *relatedForm;\n\n- (void)printSelf;\n- (void)addForm:(id)form;\n- (id)copy;\n\n@end\n```\n\n我们还有一个学校的表单：\n\n```\n@interface SchoolForm : NSObject <Form>\n@end\n\n\n@implementation SchoolForm\n@synthesize address;\n@synthesize name;\n@synthesize relatedForm;\n\n- (instancetype)init:(NSString *)name address:(NSString *)address\n{\n    self = [super init];\n    if (self) {\n        self.name = name;\n        self.address = address;\n        self.relatedForm = [[NSMutableArray alloc] init];\n    }\n    return self;\n}\n\n- (void)printSelf {\n    NSLog(@\"name=%@，address=%@\", self.name, self.address);\n}\n\n- (void)addForm:(id)form {\n    [self.relatedForm addObject:form];\n}\n\n\n- (nonnull id)copyWithZone:(nullable NSZone *)zone {\n    SchoolForm *form = [[self.class allocWithZone:zone] init:self.name address:self.address];\n    \n    for (id<Form> tform in self.relatedForm) {\n        [form.relatedForm addObject:[tform copy]];\n    }\n    return form;\n}\n@end\n```\n\n使用\n\n```\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    SchoolForm *schoolForm1 = [[SchoolForm alloc] init:@\"清华大学\" address:@\"北京\"];\n    SchoolForm *schoolForm2 = [[SchoolForm alloc] init:@\"北京大学\" address:@\"北京\"];\n    [schoolForm1 addForm:schoolForm2];\n    \n    SchoolForm *copySchool = [schoolForm1 copy];\n    \n    NSLog(@\"copySchool\");\n}\n\n@end\n```\n\n这里有一个非常有趣的问题，为什么要在`Form`协议里面添加一个copy方法，如果不写成copy，写为clone方法会怎么样？\n\n答案是NSObject类里面含有copy方法，当调用copy方法的时候回自动调用copyWithZone方法，我们在SchoolForm的copyWithZone方法里遍历了所用相关的form, 二这些form的类型实在运行时才能确定的，可能是schoolForm也可能是JobForm等等。但无论是什么类型的Form，它都继承自NSObject。所以这是一个偷梁换柱的操作，看起来像是调用`Form`协议里的copy方法，其实是调用NSObject的copy方法。换成clone的话就不能使用NSCopying协议了。\n\n### 参考\n本文参考《Objective-C编程之道：iOS设计模式解析》\n你可以在公众号里回复\"资源\"得到本书的电子版，当然建议购买正版。","tags":["设计模式"]},{"title":"iOS多线程编程二","url":"/2018/07/28/iOS多线程编程二/","content":"\n### 概述\n上一篇文章我介绍了NSThread相关的API以及使用方法，本文我们继续来讲解另一套线程相关的API, 那就是GCD。我们在开发过程中用的最多也是GCD，面试中问道最多的也是GCD。通过阅读本文，希望您对GCD的理解有新的收获。本文将讲解一下内容：\n- 队列\n- 同步与异步 \n- 举例\n\n个人认为，掌握好GCD最好的方式是彻底理解队列、同步、异步这些概念。而不是去死记硬背。死记硬背固然能应付一时，当终究不是正道，下面我们来一一解释这些概念。\n<!--more-->\n### 队列\n关于队列，我们需要明白队列是做什么的，我的理解是队列是用来存放任务的。而队列分为串行队列、并行队列。无论是串行队列还是并行队列，都是按照先进先执行的选择进行的。区别在于：对于串行队列而言，一次只能执行一个任务，该任务执行完毕之后才能执行下一个任务，而并行队列则不同，并行队列一个可以去取若干个任务执行，具体执行多个任务根据系统的环境不同而不同。下面讲述一下iOS系统中常用的队列。\n\n| 队列名称 | 描述                                                         |\n| -------- | ------------------------------------------------------------ |\n| 主队列   | 主队列是一个串行队列，运行在主线程之中。<br>经常被用来从其他线程切换到主线程操作UI。<br>可以通过` dispatch_get_main_queue() ` 获取到。 |\n| 全局队列 | 全局队列是一个并行队列，可以并发的执行一个<br>或者多个任务，经常用来执行一些简便的异步任务<br>可以通过` dispatch_get_global_queue(\"优先级\", \"\") `来获取。 |\n| 串行队列 | 串行队列是一次只能执行一个任务的队列，通常在当前线程环境下执行。<br>但多个串行队列是可以并行执行的。 |\n| 并行队列 | 并行队列通常会开启多个线程来执行队列中的任务，<br>开启的线程数量根据系统决定，因为iOS的线程是有系统统一管理的。 |\n\n加一句废话：对于GCD而言，一个block就是一个任务，一个任务在一个线程中执行。\n\n### 同步与异步\n\n同步和异步关注的是 **消息通信机制** 所谓同步，就是发出一个调用的时候，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。\n\n而异步则是相反，调用发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出之后，调用者不会立即得到结果。而是在调用发出后，被调用者通过状态，通知来告知调用者，或者通过回调函数处理这个调用。\n\n我们来看一下GCD中两个关键的API，`dispatch_async` 、`dispatch_sync` \n\n**dispatch_async:**\n\n> 该函数需要两个参数，第一个参数是一个队列，第二个参数是一个block。\n>\n> 它的作用是：将block提交给队列，调用该方法会在block提交给队列之后立即返回，不会等待block的调用。而队列决定了该block是串行执行还是和该队列里其他任务同时执行。独立的串行队列之间可以同时执行。\n\n**dispatch_sync:**\n\n> 和`dispatch_async`一样该函数同样需要两个参数。\n>\n> 它的作用是将block提交给队列并同步执行。与`dispatch_asyn`不同的是该函数不会立即返回，它会等到block的内容执行完毕之后才返回。\n>\n> 在当前队列中调用该函数，并将当前队列指定为目标队列会造成死锁。\n>\n> 与`dispatch_async`不同的是，不会对目标队列执行retain操作，因为该函数的调用是同步的，它\"借用\"调用者的引用，同时也不会对block执行block_copy操作。\n>\n> 该函数会尽可能的在当前线程上调用该block。\n\n了解了队列、同步/异步、dispatch_async/dispatch_sync之后，我们来看一下CGD的一些使用场景。\n\n### CGD的使用\n\n**例1，指出下面代码的输出结果：**\n\n```objective-c\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_queue_t queue = dispatch_queue_create(\"RiverLi\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_sync(queue, ^{\n        [NSThread sleepForTimeInterval:3];\n        NSLog(@\"%@\", NSThread.currentThread);\n    });\n    \n    NSLog(@\"11111111------>%@\", NSThread.currentThread);\n }\n```\n\n执行结果是：\n\n><NSThread: 0x604000072840>{number = 1, name = main}\n>\n>11111111------><NSThread: 0x604000072840>{number = 1, name = main}\n\n这段代码其实很好理解，`dispatch_sync` 等待block执行完毕之后在执行其之后的代码。\n\n**例2，指出下面代码的输出结果：**\n\n```objective-c\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_queue_t queue = dispatch_queue_create(\"RiverLi\", DISPATCH_QUEUE_CONCURRENT);\n    dispatch_sync(queue, ^{\n        dispatch_async(queue, ^{\n            [NSThread sleepForTimeInterval:3];\n            NSLog(@\"%@\", NSThread.currentThread);  //(a)\n        });\n    });\n    \n    NSLog(@\"11111111------>%@\", NSThread.currentThread);\t//(b)\n }\n```\n\n执行结果是：\n\n>  11111111------><NSThread: 0x600000076900>{number = 1, name = main}\n>\n> <NSThread: 0x60000027e140>{number = 3, name = (null)}\n\n分析：为什么不是先打印(a)的信息，对于`dispatch_sync` 而言，他需要等待block的执行，而block内部是一个`dispatch_async` 它提交block之后就立即返回，而它返回之后`dispatch_sync`block的内部任务已经完成，所以(b)就先执行了。3s之后，执行(a)。\n\n**例3，指出下面代码的输出结果：**\n\n```objective-c\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    dispatch_sync(dispatch_get_main_queue(), ^{\n        NSLog(@\"%@\", NSThread.currentThread);\n    });\n    NSLog(@\"11111111------>%@\", NSThread.currentThread);\n }\n```\n\n执行结果是：\n\n> 崩溃\n\n解释：首先需要注意`viewDidLoad`方法是在主队列中执行的，调用`dispatch_sync` 并传入主队列。我们知道主队列是串行队列，对串行队列而言任务是一个执行完毕之后再执行另一个任务。上面的代码主队列正在执行某一项任务，当执行到`dispatch_sync`方法时，向主队列中添加了一个任务，并等待该任务的执行完毕，然后这是主队列正在执行包含`dispatch_sync`方法的任务，这样就造成了两个任务之间的彼此等待，而造成系统崩溃。\n\n### 关于GCD源码的理解\n\n\n\n### 参考\n[Dispatch Queues](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html)\n[严肃的问答](https://www.zhihu.com/question/19732473)","tags":["多线程"]},{"title":"iOS多线程系列一","url":"/2018/07/27/iOS多线程系列一/","content":"### 概述\n本文主要讲解iOS线程相关的知识，对于一个iOS开发者，如果想保证自己所开发的应用流畅的运行，线程的知识是无法绕开的。通过阅读本文，你讲了解到如下知识：\n- 进程和线程\n- 线程的生命周期\n- NSThread基本用法\n- 线程间的通信\n\n<!--more-->\n\n### 进程和线程的\n#### 进程\n用最通俗的话来解释进程：启动一个app,就是开启了一个进程。当你使用某款App，一边浏览它所提供的内容，一边使用它下载图片，这需要用多个线程来完成上述操作。\n\n进程是应用的一次执行，线程是CPU的最小执行单元，一个进程里可以包含多个线程。\n\n### 线程的生命周期\n![线程的生命周期](http://ww1.sinaimg.cn/large/d3681d85ly1ftmcq9hlmsj20hy0icjsk.jpg)\n对于一个线程而言，它经历了`新建`、`就绪`、`运行`、`阻塞`、`死亡` 这几个阶段。解释如下：\n\n**新建：** 线程刚被创建，还没有被调用。\n\n**就绪：** 调用了线程的start的方法之后，线程就进入就绪状态。\n\n**运行：** 当CPU从就绪队列中调用到该线程，该线程进入运行状态。\n\n**死亡：** 当线程执行完毕或者线程被强制退出，线程就进入死亡状态。\n\n**阻塞：** 当正在运行的线程被其他其他优先级更高的线程抢断或者调用线程的sleep方法，线程就进入了阻塞状态，当sleep结束，线程进入就绪状态，等待CPU的调度。\n\n这是线程的最基本生命周期，iOS中与线程生命周期相关的有一个非常重要的东西就是：runloop。 本文暂不涉及这方面的知识，以后再讲解。\n\n接下来我们讲解iOS多线程相关的API，第一个就是NSThread。\n\n### NSThread的基本用法\n`NSThread`是对C语言中的线程管理相关代码的封装。用来提供面向对象的线程管理方法。\n\n**创建：**\n\n```Objective-c\n//第一种方法\nself.thread = [[NSThread alloc] initWithTarget:self selector:@selector(threadAction) object:nil];\n```\n这种方法会在线程执行的时候调用`threadAction`这个回调方法，你需要将自己的任务写在这个方法中。\n```Objective-c\n//第二种方法\nself.thread = [[NSThread alloc] initWithBlock:^{\n        NSLog(@\"%@\", [NSThread currentThread]);\n        [self task];\n    }];\n```\n这种方法会在线程执行的时候调用block里的任务，你需要将自己的任务写在block中。\n\n**开启：**\n```Objective-c\n[self.thread start];\n```\n\n**取消：**\n```Objective-c\n[self.thread cancel];\n```\n\n**休眠**\n```Objective-c\n[NSThread sleepForTimeInterval:3];\n```\n\n**获取当前线程**\n```Objective-c\n[NSThread currentThread];\n```\n**获取线程状态**\n```Objective-c\n//当前线程是不是主线程\nself.thread.isMainThread\n//当前线程是不是正在执行\nself.thread.isExecuting\n//当前线程是不是执行完毕了\nself.thread.isFinished\n//当前app是不是一个多线程app, 对于iOS而已，肯定是的，返回YES\nself.thread.isMultiThreaded\n```\n**注意：** 对于一个已经finished的线程，不能再调用其start方法了，会崩溃。\n\n### 线程间的通信\n在iOS中，UI相关的操作需要回到主线程进行操作，那么如何在NSThread线程中回到主线程呢？\n```Objective-c\n//回到主线程执行\n[self performSelectorOnMainThread:@selector(onMainThreadWork) withObject:nil waitUntilDone:NO];\n\n//回到指定的线程执行\n[self performSelector:@selector(方法名) onThread:执行的线程 withObject:参数 waitUntilDone:是否阻塞];\n```\n\n`waitUntilDone`这个参数表示是否阻塞当前代码，yes表示阻塞，selecotor方法不执行完毕，则代码一直阻塞在这里，不往下执行。no表示不阻塞，即不等待selector方法执行完毕。·\n","tags":["多线程"]},{"title":"HTTPS","url":"/2018/07/18/HTTPS/","content":"\n### 概述\n\nHTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TSL协议代替而已。通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。\n\n\n### HTTP缺点\n\n- 通信使用明文（不加密），内容可能会被窃听。\n- 不验证通信方的身份，因此有可能遭遇伪装。\n- 无法证明报文的完整性，所以有可能已遭篡改。\n<!--more-->\n\n\n### HTTPS中的加密方式\n\n**共享密钥加密:** 加密和解密同用一个密钥的方式称为共享加密，也被叫做`对称密钥加密` 或`对称加密`。\n\n**公开密钥加密:** 使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。私有密钥不能让其他任何人知道, 而公开密钥则可以随意发布，任何人都可获得。又称为`非对称密钥加密` 或 `非对称加密`。\n\n在交换密钥环节使用 **公开密钥加密** 方式、之后的建立通信交换报文阶段则使用 **共享密钥加密** 方式。\n\n所以\n\n在交换密钥环节使用 **对称加密**方式，之后建立通信交换报文阶段则使用**非对称密码**方式。\n\n1. 使用公开密钥加密方式安全地交换在稍后共享密钥加密中要使用的密钥。\n2. 确保交换的密钥是安全的前提下，使用共享密钥加密方式进行通信。\n\n\n\n### SSL链接建立流程\n\n![SSL](http://ww1.sinaimg.cn/large/d3681d85ly1ftco7vqeutj20ca0e7jsr.jpg)\n\n1. 客户端先向服务器发出加密通信请求，这被叫做ClientHello请求。该请求携带如下信息。\n\n   ```swift\n   1. 支持的协议版本，比如TLS1.0版。\n   2. 一个客户端生成的随机数，稍后用户生成“对话密钥”。\n   3. 支持的加密方法，比如RSA公钥加密。\n   4. 支持的压缩方法。\n   ```\n\n2. 服务器收到客户端请求后，向客户端发出回应。这个叫做SeverHello，服务器的回应包含以下内容。\n\n   ```swift\n   1. 确认使用的加密通信协议版本。\n   2. 一个服务器生成的随机数。\n   3. 确认使用的加密方法。\n   4. 服务器证书。\n   ```\n\n   **注意：** 如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供“客户端证书”。\n\n3. 客户端收的到服务器的回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。\n\n   如果证书没有问题，客户端就会从证书中取出公钥，然后向服务器发生下面三项信息：\n\n   ```swift\n   1. 一个随机数。该随机数使用服务器公钥加密，防止被窃听。\n   2. 编码改变通知，表示随后的信息都将用双方上商定的加密方法和密钥发送。\n   3. 客户端握手结束通知，表示客户端握手阶段已经结束。这一项也是前面发送的所有内容的hash值，用来供服务器校验。\n   ```\n\n   上面第一项随机数，是整个握手阶段出现的第三个随机数，又称为“pre-master-key”。有了它以后，客户端和服务器同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把“会话密钥”。\n\n   为什么要用三个随机数：\n\n   ```\n   \"不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。\n   \n   对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。\n   \n   pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的可不是一。\"\n   ```\n\n   此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。\n\n4. 服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的\"会话密钥\"。然后，向客户端最后发送下面信息。\n\n   ```\n   1. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。\n   2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。\n   ```\n\n   至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用\"会话密钥\"加密内容。\n\n\n\n### 证书验证流程\n\n我SSL连接过程中，第二步客户端从服务端接收到证书，如何验证证书的有效性呢？ 这里需要引出一个第三方机构，数字证书认证机构，这个机构是值得信赖的。证书验证流程如下：\n\n![证书校验](http://ww1.sinaimg.cn/large/d3681d85ly1fte330afjtj21120m6tc7.jpg)\n\n客户端一般会内置数字认证机构的公开密钥。\n\n### 参考\n\n[SSL/TLS协议运行机制的概述](http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html)\n\n[图解HTTP](https://item.jd.com/11449491.html)","tags":["HTTPS"]},{"title":"iOS挖矿了解一下？","url":"/2018/06/01/iOS挖矿了解一下？/","content":"### 区块链与挖矿\n\n如果要问你2018年互联网什么最火？肯定是区块链啊！有多火？听说前几天区块链大会上毛爷爷都现身了😅。区块链是啥，百度百科的解释是`区块链是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式`。😯好复杂有木有，那区块链能干啥？那很多啦，比如说发币、挖矿还有🤐。再说炒币，听说是韭菜割了一茬又一茬，郁郁葱葱，野火烧不尽啊。\n\n说正事，iOS设备怎么挖矿。我使用的是[xmrig](https://github.com/xmrig/xmrig)，官方提供了window平台的支持，提供了MacOS等平台的编译方法，唯独没有iOS和Android设备，可是我想用我的iPhone挖一挖啊，不中，我得看看能不能编译出来iOS的包。\n<!--more-->\n###  编译xmrig for iOS\n\nxmrig的作者使用C++封装了门罗币算法，如果如果我们要在iOS平台上使用有两种方案：\n\n1. 源码拖到iOS工程里，直接调用C++方法，因为OC或者Swift与C++是可混编的。\n2. 编译成静态库，导入工程使用。\n\n有兴趣的朋友可以试试方法一，反正我是放弃了，卡卡卡全是错。接下来我介绍方法二。\n\n#### 编译静态块\n\n1. clone xmrig\n\n```shell\ngit clone https://github.com/xmrig/xmrig.git\n```\n\n可以看到根目录里面有一个`CMakeLists.txt`文件，这个文件里定义了编译规则。\n\n1. ios-cmake\n\ncmake是一个夸平台编译工具，具体可参考[cmake](http://www.hahack.com/codes/cmake/)。github上有一个针对iOS平台的cmake工具[ios-cmake](https://github.com/leetal/ios-cmake)。同样clone到本地\n\n```shell\ngit clone https://github.com/leetal/ios-cmake\n```\n\n1. 编译libuv for ios\n\nxmrig依赖于libuv，但libuv没有iOS的版本，我们需要针对编译，具体可参考我之前的文章[libuv移植的iOS平台](http://riverli.me/2018/05/31/2018-05-20%E5%91%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/)\n\n1. 修改 CMakeLists.txt\n\n   1. 添加静态库标识\n\n   ```shell\n   add_library( # Sets the name of the library.\n                native-lib\n                # Sets the library as a shared library.\n                 # SHARED\n               STATIC\n                # Provides a relative path to your source file(s).\n                ${HEADERS} ${SOURCES} ${SOURCES_OS} ${SOURCES_CPUID} ${HEADERS_CRYPTO} ${SOURCES_CRYPTO})\n   ```\n\n   1. 指定C++版本\n\n   ```shell\n   set (CMAKE_CXX_STANDARD 11)\n   ```\n\n   1. 添加install 命令\n\n   ```shell\n   //导出文件路径\n   set (CMAKE_INSTALL_PREFIX \"自定义路径\")\n   install (TARGETS native-lib DESTINATION .)\n   install (FILES ${HEADERS} ${HEADERS_CRYPTO} DESTINATION .)\n   ```\n\n   **注意：**你需要根据具体报错信息去修改这个文件。\n\n2. 开始编译\n\n   在根目录依次执行如下命令：\n\n   ```shell\n   //命令1\n   cmake .. -DWITH_HTTPD=OFF -DWITH_LIBCPUID=OFF -DUV_INCLUDE_DIR=\"libuv include文件路径\" -DUV_LIBRARY=\"libuv.a文件的路径\" -DCMAKE_TOOLCHAIN_FILE=\"ios-cmake文件路径\" -DENABLE_ARC=0 -DENABLE_BITCODE=0\n   //命令2\n   make\n   //命令3\n   make install\n   ```\n\n   之后你会在第四步设置的导出文件里看到导出的静态库以及头文件。\n\n3. 将静态库已经头文件拖入工程、调用相关方法执行。这里的具体调用我就不细说了。因为不同的版本调用方式不一样，差异挺大。核心的方法都集中在`crypto`文件下。\n\n4. 执行，我用我的iPhone6测试机单线程算力在6H/s，双线程在11H/s，下图是apple测试员在ipad上的执行效果。\n\n   ![效果](http://ww1.sinaimg.cn/mw690/d3681d85ly1frvml52zb1j208c0b4q31.jpg)\n\n   ### 上架\n\n   目前AppStore是不允许类似的应用上架的，因为违反了`Guideline 1.4.5 - Safety - Physical Harm`。当然你可以以其他方式达到上架的目的。\n\n   ### 小白挖矿\n\n   如果你对挖矿感兴趣可以使用[哈鱼矿工](http://hashfish.net/)这个软件，目前这个软件实现了在Window、MacOS、Linux等系统上一键挖矿，而且目前是0抽成还有收徒红包。并且任何使用问题都可以在官方QQ群中咨询。QQ群号：624825298","tags":["iOS 挖矿"]},{"title":"ReactNative实践","url":"/2018/06/01/ReactNative实践/","content":"### 关于React-Native\n\nReact-Native号称是跨平台开发且具有原生应用的体验，早在两年前我曾经尝试过使用React-Native，但是环境搭建过程及其复杂，可参见我之前写的文章：[iOS现有项目手动集成ReactNative](https://www.jianshu.com/p/66214bc6377f)。最近公司新开项目需要实现iOS和Android平台热更新方案，以便快速开展业务。本文用来梳理React-Native在iOS上的一些实践。包括如下内容：\n<!--more-->\n- 搭建一个React-Native项目。\n- 现有iOS项目中集成React-Native模块。\n- 以bundle的形式在真机上运行React-Native。\n- 热更新中bundle的拆分。\n\n由于React-Native项目一直在更新，不同的版本在使用的过程中会遇到不同的问题，所以强烈建议你使用[英文官方文档](https://facebook.github.io/react-native/)作为开发参考。\n\n### 搭建一个React-Native项目\n\n根据React-Native的官方文档一路能一路很顺利的搭建成功。我这里简单说一下主要步骤，详细可参考：[安装文档](https://facebook.github.io/react-native/docs/getting-started.html)\n\n1. 安装依赖，包括Node、Watchman、React Native命令行界面、Xcode。\n\n   1. 建议使用[homebrew](https://brew.sh/)安装node和Watchman\n\n   ```shell\n   brew install node\n   brew install watchman\n   ```\n\n   1. 安装 React Native CLI\n\n   ```shell\n   npm install -g react-native-cli\n   ```\n\n   1. Xcode，作为一个iOS开发，就不多说了。\n\n2. 创建项目\n\n   ```shell\n   react-native init AwesomeProject\n   ```\n\n3. 运行项目\n\n   ```shell\n   cd AwesomeProject\n   react-native run-ios\n   ```\n\n4. 如果顺利的话你可以看到你的第一个React-Native项目了。\n\n### 基础React Native到现有项目\n\n同样我建议你参考[官方文档](https://facebook.github.io/react-native/docs/integration-with-existing-apps.html)，我现有项目是Swift，你可以根据你的项目情况选择对应的安装方法。\n\n1. 调整项目结构如下，新建iOS目录，将iOS相关的代码都放到iOS目录下。\n2. 在iOS同级目录下创建`package.json`文件\n\n```json\n{\n  \"name\": \"MyReactNativeApp\",\n  \"version\": \"0.0.1\",\n  \"private\": true,\n  \"scripts\": {\n    \"start\": \"node node_modules/react-native/local-cli/cli.js start\",\n    \"postinstall\": \"sed -i '' 's/#import <RCTAnimation\\\\/RCTValueAnimatedNode.h>/#import <React\\\\/RCTValueAnimatedNode.h>/' ./node_modules/react-native/Libraries/NativeAnimation/RCTNativeAnimatedNodesManager.h; sed -i '' 's/#import <fishhook\\\\/fishhook.h>/#import <React\\\\/fishhook.h>/' ./node_modules/react-native/Libraries/WebSocket/RCTReconnectingWebSocket.m\"\n  },\n  \"dependencies\": {\n    \"react\": \"^16.4.0\",\n    \"react-native\": \"^0.55.4\"\n  }\n}\n\n```\n\n1. 安装yarn\n\n```shell\nbrew install yarn\n```\n\n1. 安装React-native\n\n```shell\nyarn add react-native\n```\n\n如果出现警告\n\n`warning \"react-native@0.52.2\" has unmet peer dependency \"react@16.2.0\".`\n\n则你需要安装React\n\n```shell\nyarn add react@version_printed_above // version_printed_above 具体版本号\n```\n\n1. 在iOS目录里添加podfile文件\n\n```shell\n# Uncomment the next line to define a global platform for your project\nplatform :ios, '9.0'\n\ntarget 'ReactDemo' do\n  # Comment the next line if you're not using Swift and don't want to use dynamic frameworks\n  use_frameworks!\n\n  # Pods for ReactDemo\n\npod 'React', :path => '../node_modules/react-native', :subspecs => [\n'Core',\n'CxxBridge', # Include this for RN >= 0.47\n'DevSupport', # Include this to enable In-App Devmenu if RN >= 0.43\n'RCTText',\n'RCTNetwork',\n'RCTWebSocket', # needed for debugging\n Add any other subspecs you want to use in your project\n]\npod 'yoga', :path => '../node_modules/react-native/ReactCommon/yoga'\n\n# Third party deps podspec link\npod 'DoubleConversion', :podspec => '../node_modules/react-native/third-party-podspecs/DoubleConversion.podspec'\npod 'glog', :podspec => '../node_modules/react-native/third-party-podspecs/glog.podspec'\npod 'Folly', :podspec => '../node_modules/react-native/third-party-podspecs/Folly.podspec'\n\n\n  target 'ReactDemoTests' do\n    inherit! :search_paths\n    # Pods for testing\n  end\n\n  target 'ReactDemoUITests' do\n    inherit! :search_paths\n    # Pods for testing\n  end\n\nend\n\ndef fix_cplusplus_header_compiler_error\n    filepath = '../node_modules/react-native/React/Base/Surface/SurfaceHostingView/RCTSurfaceSizeMeasureMode.h'\n    \n    contents = []\n    \n    file = File.open(filepath, 'r')\n    file.each_line do | line |\n        contents << line\n    end\n    file.close\n    \n    if contents[32].include? \"&\"\n        contents.insert(26, \"#ifdef __cplusplus\")\n        contents[36] = \"#endif\"\n        \n        file = File.open(filepath, 'w') do |f|\n            f.puts(contents)\n        end\n    end\nend\n\ndef fix_unused_yoga_headers\n    filepath = './Pods/Target Support Files/yoga/yoga-umbrella.h'\n    \n    contents = []\n    \n    file = File.open(filepath, 'r')\n    file.each_line do | line |\n        contents << line\n    end\n    file.close\n    \n    if contents[12].include? \"Utils.h\"\n        contents.delete_at(15) # #import \"YGNode.h\"\n        contents.delete_at(15) # #import \"YGNodePrint.h\"\n        contents.delete_at(15) # #import \"Yoga-internal.h\"\n        contents.delete_at(12) # #import \"Utils.h\"\n        \n        file = File.open(filepath, 'w') do |f|\n            f.puts(contents)\n        end\n    end\nend\n\ndef react_native_fix\n    fix_cplusplus_header_compiler_error\n    fix_unused_yoga_headers\nend\n\npost_install do |installer|\n    react_native_fix\nend\n\n```\n\n执行pod install命令。\n\n1. 在iOS同级目录创建index.ios.js，写入相关内容。\n\n```js\nimport React from 'react';\nimport {AppRegistry, StyleSheet, Text, View} from 'react-native';\n\nclass RNHighScores extends React.Component {\n  render() {\n    var contents = this.props['scores'].map((score) => (\n      <Text key={score.name}>\n        {score.name}:{score.value}\n        {'\\n'}\n      </Text>\n    ));\n    return (\n      <View style={styles.container}>\n        <Text style={styles.highScoresTitle}>2048 High Scores!</Text>\n        <Text style={styles.scores}>{contents}</Text>\n      </View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n    backgroundColor: '#FFFFFF',\n  },\n  highScoresTitle: {\n    fontSize: 20,\n    textAlign: 'center',\n    margin: 10,\n  },\n  scores: {\n    textAlign: 'center',\n    color: '#333333',\n    marginBottom: 5,\n  },\n});\n\n// Module name\nAppRegistry.registerComponent('RNHighScores', () => RNHighScores);\n```\n\n1. 在iOS项目中调用React Native模块\n\n```swift\n@IBAction func highScoreButtonTapped(sender : UIButton) {\n  NSLog(\"Hello\")\n  let jsCodeLocation = URL(string: \"http://localhost:8081/index.bundle?platform=ios\")\n  let mockData:NSDictionary = [\"scores\":\n      [\n          [\"name\":\"Alex\", \"value\":\"42\"],\n          [\"name\":\"Joel\", \"value\":\"10\"]\n      ]\n  ]\n\n  let rootView = RCTRootView(\n      bundleURL: jsCodeLocation,\n      moduleName: \"RNHighScores\",\n      initialProperties: mockData as [NSObject : AnyObject],\n      launchOptions: nil\n  )\n  let vc = UIViewController()\n  vc.view = rootView\n  self.present(vc, animated: true, completion: nil)\n}\n```\n\n1. 配置info.plist\n\n```shell\n<key>NSAppTransportSecurity</key>\n<dict>\n    <key>NSExceptionDomains</key>\n    <dict>\n        <key>localhost</key>\n        <dict>\n            <key>NSTemporaryExceptionAllowsInsecureHTTPLoads</key>\n            <true/>\n        </dict>\n    </dict>\n</dict>\n```\n\n1. 启动npm\n\n```shell\nnpm start\n```\n\n1. 运行\n\n```shell\nreact-native run-ios\n```\n\n### 真机运行 \n\n在真机上运行ReactNative项目有两种方式，本文只说第二种\n\n- 手机和电脑在同一个局域网，将上述代码的localhost改为机器ip。\n- 打包出jsbundle\n\n在iOS目录创建release_ios文件夹，执行如下命令\n\n```shell\nreact-native bundle --entry-file index.ios.js --platform ios --dev false --bundle-output release_ios/main.jsbundle --assets-dest release_ios/\n```\n\n会将js打包成main.jsbundle，将图片等输出到asset目录。将这些内容拖入工程，修改加载React-Native代码\n\n```swift\nlet jsCodeLocation = Bundle.main.url(forResource: \"main\", withExtension: \"jsbundle\")\n```\n\n这样就可以直接在真机上运行了。\n\n### 热更新bundle的拆分与合并\n\n这方面的详解我推荐[necfol的方案](https://necfol.com/2018/04/02/ReactNative%E7%83%AD%E6%9B%B4%E6%96%B0%E4%B8%8E%E6%8B%86%E5%8C%85iOS%E7%89%88/)，我就不多说废话了，人家的图那么清晰，还有Demo，我只能推荐了。\n\n### 参考\n\n[含泪导入React-native 0.54到Swift原生项目](https://www.jianshu.com/p/611b49ccf351)","tags":["ReactNative"]},{"title":"Moya基本用法","url":"/2018/05/31/Moya基本用法/","content":"\n### Moya简介\n\n一句话来讲，[Moya](https://github.com/Moya/Moya)是对[Alamofire](https://github.com/Alamofire/Alamofire)的封装，让开发人员更加优雅的使用Alamofire。\n\n### 基本用法\n\n1. 定义接口枚举\n\n   ```swift\n   public enum HFAPI {\n       case login(String, String, String) //登录接口\n       case smscode(String)    //登录，发送验证码\n   }\n   ```\n<!--more-->\n\n1. 拓展枚举并实现TargetType，代码详解如下：\n\n   ```swift\n   extension HFAPI: TargetType {\n       \n       public var baseURL: URL {\n           return URL.init(string: \"接口域名\")!;\n       }\n       \n       public var path: String {\n           switch self {\n           case .login:\n               return \"login接口路径\"\n           case .smscode:\n               return \"smscode接口路径\"\n           }\n       }\n       \n       //请求接口时使用的方法\n       public var method: Moya.Method {\n           switch self {\n           case .login:\n               return .post\n           case .smscode:\n               return .get\n           }\n       }\n       \n    \t//请求接口时对应的请求参数\n       public var task: Task {\n           var params:[String : Any] = [:]\n           \n           params[\"v\"] = ProjectInfo.appVersionWithOutPoint()\n           params[\"dev\"] = ProjectInfo.platform()\n           switch self {\n               case.login(let smsCodeToken, let smsCode, let phone):\n                   params[\"smsCodeToken\"] = smsCodeToken\n                   params[\"smsCode\"] = smsCode\n                   params[\"phone\"] = phone\n                   break;\n               case .smscode(let phone):\n                   params[\"phone\"] = phone\n                   break;\n           }\n           return .requestParameters(parameters: params, encoding: URLEncoding.default)\n       }\n       \n       //header信息\n       public var headers: [String : String]? {\n           var header: [String:String] = [:]\n           let token = HFDefault.getToken()\n           if token.count > 0 {\n               header[\"X-Token\"] = token\n           }\n           return header\n       }\n       \n       //用于单元测试\n       public var sampleData: Data {\n           switch self {\n           case .login:\n               return \"{\\\"id\\\": \\\"1\\\", \\\"first_name\\\": \\\"Harry\\\", \\\"last_name\\\": \\\"Potter\\\"}\".data(using: String.Encoding.utf8)!\n           default:\n               return Data()\n           }\n       }\n   }\n   ```\n\n   `sampleData`是用于单元测试的，我们可以使用Xcode自带的单元测试工具来自测，测试用例如下：\n\n   ```swift\n   func testSmscodeAPI() {\n           let loginProvitder = MoyaProvider<HFAPI>(stubClosure: MoyaProvider.immediatelyStub)\n           loginProvitder.request(.smscode(\"17755558888\")) { result in\n               switch result {\n               case let .success(moyaResponse):\n                   let statusCode = moyaResponse.statusCode // Int - 200, 401, 500, etc\n                   let data = String.init(data: moyaResponse.data, encoding: String.Encoding.utf8)\n                   print(\"\\(statusCode)\")\n                   print(data ?? \"no data\")\n               case .failure(_):\n                   break\n               }\n           }\n       }\n   ```\n\n2. 自定义超时时间\n\n   ```swift\n    public static func hFApiProvider(timeInterval:TimeInterval  = 15) -> MoyaProvider<HFAPI> {\n           return MoyaProvider<HFAPI>(\n               requestClosure: { (endPoint, closure) in\n                   do {\n                       var urlRequest = try endPoint.urlRequest()\n                       urlRequest.timeoutInterval = timeInterval;\n                       closure(.success(urlRequest))\n                   } catch MoyaError.requestMapping(let url) {\n                       closure(.failure(MoyaError.requestMapping(url)))\n                   } catch MoyaError.parameterEncoding(let error) {\n                       closure(.failure(MoyaError.parameterEncoding(error)))\n                   } catch {\n                       closure(.failure(MoyaError.underlying(error, nil)))\n                   }\n           })\n       }\n   ```\n\n3. 错误处理\n\n   ```swift\n   struct HFNetWork {\n       \n       public static func request(provider: MoyaProvider<HFAPI>,\n                           target: HFAPI,\n                           success successCallback: @escaping (JSON) -> Void,\n                           error errorCallback: @escaping (Int) -> Void,\n                           failure failureCallback: @escaping (MoyaError) -> Void) {\n           provider.request(target) { result in\n               switch result {\n               case let .success(response):\n                   do {\n                       let json = try JSON(response.filterSuccessfulStatusCodes().mapJSON())\n                       successCallback(json)\n                   }\n                   catch let error {\n                       errorCallback((error as! MoyaError).response!.statusCode)\n                   }\n               case let .failure(error):\n                   failureCallback(error)\n               }\n           }\n       }\n   }\n   ```\n\n4. 调用\n\n   ```swift\n   HFNetWork.request(provider: HFAPI.hFApiProvider(), target: .smscode(phone), success: { (json) in\n               let jsonString = json.rawString() ?? \"\"\n               if jsonString.count <= 0 {\n                   return\n               }\n               let responseObject = ResponseModel(JSONString: jsonString)\n               guard let fResponseObject = responseObject else {\n                   return\n               }\n               \n               HFLog.info(fResponseObject.data)\n           }, error: { (errorcode) in\n           }) { (error) in\n           }\n   }\n   ```","tags":["Moya"]},{"title":"2018-05-20周问题汇总","url":"/2018/05/31/2018-05-20周问题汇总/","content":"## pod init报错\n错误信息如下\n```\nRuntimeError - [Xcodeproj] Unknown object version. #7697\n```\n在issues中的讨论中给出了很多解决方案，最终我的解决方案是修改项目的配置，我的Xcode版本是9.3\n![修改项目配置](https://user-gold-cdn.xitu.io/2018/5/20/1637bf546c46262e?w=864&h=400&f=png&s=56024)\n具体讨论参考：[Github](https://github.com/CocoaPods/CocoaPods/issues/7697)\n\n## libuv移植的iOS平台\nlibuv是一个跨平台的，高性能的，事件驱动的I/O库。具体教程见[libuv](http://luohaha.github.io/Chinese-uvbook/source/introduction.html)。\n<!--more-->\n具体步骤：\n1. 安装Python\n2. 下载[libuv源码](https://github.com/libuv/libuv)\n3. 在终端中进入libuv目录。\n4. 创建build目录。`mkdir -p build`\n5. 下载gyp  `https://chromium.googlesource.com/experimental/external/gyp`\n6. 执行 ` ./gyp_uv.py -f xcode`，会在在output目录生成uv.xcodeproj\n7. 打开uv.xcodeproj，修改配置如下：\n``` xml\nBaseSDK：Latest IOS\nArchitecture : armv7,armv7s,arm64\nsupported platform: IOS\nvalid architecture: arm64 armv7 armv7s\n```\n8. 以IOS Device为目标编译，生成真机版的库libuv.a，在Debug-iphoneos目录下\n以Simulater为目标编译，生成模拟器版的库libuv.a，在Debug-iphonesimulater目录下\n9. 将两个库合成一个库 \n```xml\nlipo -create Debug-iphoneos/libuv.a Debug-iphonesimulator/libuv.a -output libuv.a\n```\n参考:[libuv移植到iOS](http://www.cnblogs.com/guoxiaoqian/p/3979952.html)\n\n## CMake\nCMake是一个跨平台的编译工具。具体简介可参考教程[CMake](http://www.hahack.com/codes/cmake/)。在iOS平台可以使用开源库[ios-cmake](https://github.com/leetal/ios-cmake)。\n\n**Mac 上 cmake 使用C++11编译**\nMac上clang编译器默认的C++版本比较低，一些特性语法会报错，需要修改编译版本，在CMakeLists.txt文件中添加\n```\nset (CMAKE_CXX_STANDARD 11)\n```\n\n### 将Mac系统上的C、C++编译器切换到GCC\n我们都知道Mac上的默认编译器是Clang，下面简单介绍一些如何切换成GCC。步骤如下：\n1. 打开终端，输入`sudo vim ~/.bash_profile`\n2. 添加如下配置，gcc-4.7是响应的gcc版本号。\n```\nalias gcc='gcc-4.7'\nalias cc='gcc-4.7'\nalias g++='g++-4.7'\nalias c++='c++-4.7'\n```\n3. 执行`source ~/.bash_profile`\n4. 执行`gcc --version`查看版本信息。\n![gcc --version](https://user-gold-cdn.xitu.io/2018/5/20/1637c1666140833c?w=1072&h=176&f=jpeg&s=62475)\n\n## 共享Windows桌面\n有时候我们需要使用Mac电脑控制同一个局域网下的window电脑，推荐一个软件`Microsoft Remote Desktop` 可以在AppStore上下载，不过需要使用美区账号，中国区没有上架。下载之后添加一个连接，配置如下\n![连接配置](https://user-gold-cdn.xitu.io/2018/5/20/1637c2278be97d75?w=860&h=1040&f=jpeg&s=127841)\n","tags":["总结"]},{"title":"iOS私有Api查找","url":"/2018/05/12/iOS私有Api查找/","content":"### 背景\n新发版的App因为调用了私有**com.apple.springboard.lockcomplete**被拒\n![邮件信息](http://upload-images.jianshu.io/upload_images/691666-e65cf1e018046b03.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 解决办法\n由邮件内容可知，appple建议我们使用 __strings__ 或者 __otool__ 命令来查找对应的内容，我使用的strings命令。具体做法如下：\n1. 打出release包到本地。\n2. 将后缀 __.ipa__ 修改为 __.zip__ \n3. 解压zip文件。\n4. 打开命令行输入 __cd ~/Desktop/wkcast-ios 2018-04-25 16-12-16/test/Payload/test.app__ \n5. 执行 __ strings - -a -arch armv7 \"test\" > test.txt __ 命令。\n6. 打开 __test.txt__ 文件搜索对应的字符串，该文件位于 __wkcast-ios.app__ 内部，需要使用 右键->展示包内容找到它。\n__注意：__ test为项目名称","tags":["iOS"]},{"title":"dispatch_sync死锁问题分析","url":"/2018/04/11/dispatch-sync死锁问题分析/","content":"### 示例代码\n\n```objective-c\ndispatch_sync(dispatch_get_main_queue(), ^{\nNSLog(@\"11111\");\n});\n```\n\n在按钮的响应事件中执行如下代码，会造成死锁，简单分析一下死锁的原因：\n\ndispatch_sync 是同步执行，该方法会阻塞线程，等到block内容执行完之后，其后面的代码才有机会执行。\n\n如上代码，dispatch_sync将block任务提交到主队列中，等待执行。\n\n我们知道，主队列是一个串行队列，串行队列的特点是先进先出。对于iOS而言，主队列有很多任务要执行，基本没有可能当你执行上面代码的时候，主队列中没有任何任务。\n\n假设，执行到上述代码的时候，主队列里有3个待执行任务，这时将第四个任务(也就是上述代码的Block)，提交到主队列。这时候，主队列中有四个任务，主队列要先执行前三个任务，才能执行第四个任务，但是dispatch_sync阻塞函数，主队列要先执行完第四个任务，主队列才有时机去执行前三个任务。所以代码处于死锁状态。\n","tags":["iOS"]},{"title":"ios架构学习-View层","url":"/2018/04/04/ios架构学习-View层/","content":"### 概述\n最近在读casatwy的博客，收获良多，从中学习了很多知识，本文一方面是梳理自己学到的知识，另一方是形成自己的代码风格。本文重度参考casatwy的博客，参考以及相关阅读模块贴出来相关链接，都是极其优秀的文章，希望你也能从中有所收获。\n<!--more-->\n### View代码结构\n```objective-c\n#import <UIKit/UIKit.h>\n\n@interface ViewController ()<UITableViewDelegate>\n@property (nonatomic, strong)UITableView *tableView;\n@end\n\n@implementation VideoPlayHistoryViewController\n#pragma mark - 生命周期方法(以下是生命周期方法)\n- (void)viewDidLoad {\n    [super viewDidLoad];\n}\n\n#pragma mark - UITableViewDelegate(以下是代理方法)\n- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath {\n    \n}\n\n#pragma mark - 事件响应方法(以下是事件响应方法)\n- (IBAction)btnClicked:(UIButton *)sender {\n    \n}\n\n#pragma mark - getter and setter方法(以下是getter and setter)\n-(UITableView *)tableView {\n    if(!_tableView) {\n        \n    }\n    return _tableView;\n}\n@end\n```\n\n__注意点:__\n* 所有属性均使用getter或者setter方法进行初始化。\n* 正常情况下ViewController里不应该存在私有的逻辑方法。\n* 每一个delegate都应该带上对应的协议名。\n* getter和setter方法放在最后面。\n* 所有的事件和手势的响应方法放在一块。\n* viewDidLoad方法不需要做复杂的布局计算，只需要做布局的增加操作。\n* 页面的布局写在一个单独的方法里，在响应的时机调用，参考文章：TODO\n* 属性的定义使用`@property`来定义，公开的属性放在.h文件里，私有的属性放在.m文件里。\n* 不要在init和dealloc函数中使用accessor。\n\n按照如上要求做，写出来的ViewController简洁、易读。\n\n### View的布局 frame or autolayout\n目前建议尽量使用自动布局, View的布局分为Frame布局和自动布局。推荐两个框架：\n* Frame布局，[HandyAutoLayout](https://github.com/casatwy/HandyAutoLayout)\n* 自动布局，[Masonry](https://github.com/SnapKit/Masonry)\n自动布局的好处是，如果后期有转屏的需求，比如说加入了视频播放的功能，前期代码使用自动布局会大大方便后期的开发工作。\n\n### Storyboard、Xib与手写View的选择\n选择那种方式可以根据具体的情况做斟酌，原则是：简单的且不易改动页面使用Xib(比如说:关于页),其他情况一律使用代码。\n\n### 是否派生ViewController\n不派生，使用AOP进行相关的设置。\n\n### 禁止做的\n* 不要在UIWindow上直接添加视图。\n\n### 参考以及相关阅读\n[iOS应用架构谈 view层的组织和调用方案](https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html)\n[Why getter and setter methods are evil](https://www.javaworld.com/article/2073723/core-java/why-getter-and-setter-methods-are-evil.html)\n[Aspects](https://github.com/steipete/Aspects)\n[跳出面向对象思想(一) 继承](https://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-yi-ji-cheng.html)\n[跳出面向对象思想(二) 多态](https://casatwy.com/tiao-chu-mian-xiang-dui-xiang-si-xiang-er-duo-tai.html)\n[iOS 开发中的争议（一）](http://blog.devtang.com/2015/03/15/ios-dev-controversy-1/)\n[iOS 开发中的争议（二）](http://blog.devtang.com/2015/03/22/ios-dev-controversy-2/)\n[座谈会：移动开发中的痛点](http://www.infoq.com/cn/news/2015/04/symposium-web-mvc)\n[不要在init和dealloc函数中使用accessor](http://blog.devtang.com/2011/08/10/do-not-use-accessor-in-init-and-dealloc-method/)\n","tags":["iOS"]},{"title":"Mac清理Xcode缓存脚本","url":"/2018/04/04/Mac清理Xcode缓存脚本/","content":"由于电脑存储空间有限，总是要定期清理Xcode缓存，所以写了一个脚本，提高效率，需要的朋友可以替换一下路径，方面使用。\n<!--more-->\n```python\n#!usr/bin/python\n#-*-coding:UTF-8-*-\n\nimport os\nfrom subprocess import call \n\npath1 = \"/Users/river/Library/Developer/Xcode/DerivedData\"\npath2 = \"/Users/river/Library/Developer/Xcode/Archives\"\npath3 = \"/Users/river/Library/Developer/CoreSimulator/Devices\"\npath4 = \"/Users/river/Library/Developer/XCPGDevices\"\n\n\nos.chdir(path1)\nos.system('pwd')\nos.system('rm -rf *')\nprint 'DerivedData文件清理完成'\n\nos.chdir(path2)\nos.system('pwd')\nos.system('rm -rf *')\nprint 'Archives文件清理完成'\n\nos.chdir(path3)\nos.system('pwd')\nos.system('rm -rf *')\nprint 'CoreSimulator/Devices文件清理完成'\n\nos.chdir(path4)\nos.system('pwd')\nos.system('rm -rf *')\nprint 'XCPGDevices文件清理完成'\n```\n\n### 最后\n本博客没有做评论系统，如果您对文章有意见，请到[关于我](http://riverli.me/about/)页面获取我的联系方式。\n另外，如果您觉得本文对你有帮助，可以友情给予鼓励，谢谢！\n![微信扫码赏赞](https://ws1.sinaimg.cn/mw690/d3681d85ly1fq0faf7eimj20u00u0q3t.jpg)\n","tags":["效率"]},{"title":"dispatch_after与performSelectorwithObjectafterDelay比较","url":"/2018/04/04/dispatch-after与performSelectorwithObjectafterDelay比较/","content":"\n在日常开发中，我们会经常遇到一些延迟执行的需求，通常的实现方式有：\n\n- 使用dispatch_after\n- 使用performSelector:withObject:afterDelay:\n\n本文主要分析这两种方法使用时候的注意事项以及实现原理\n<!--more-->\n### dispatch_after\n\n**函数声明：**\n```objective-c\nvoid dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);\n```\n\n**参数解析：**\nwhen: 时间节点，使用`dispatch_time` 或者`dispatch_walltime`创建。\nqueue: block所提交的队列，这个队列由系统强引用，直到block执行完毕。不能为NULL。\nblock: 需要提交的任务，该函数会自动执行`Block_copy` and `Block_release`方法。不能为NULL。\n\n**讨论：**\n该方法等到指定的时间节点后异步地将block任务添加到指定的队列。可以将`DISPATCH_TIME_NOW`传递给when参数，但这种做法不如直接调用`dispatch_async`。将`DISPATCH_TIME_FOREVER`传递给when参数是没有任何意义的。\n\n**实现原理：**\ndispatch_after的实现是依赖于定时器`dispatch_source_set_timer`。\n```objective-c\nvoid dispatch_after_f(dispatch_time_t when, \n                      dispatch_queue_t queue, \n                      void *ctxt, \n                      dispatch_function_t func) {  \n    uint64_t delta;\n    struct _dispatch_after_time_s *datc = NULL;\n    dispatch_source_t ds;\n\n    // 如果延迟为 0，直接调用 dispatch_async\n    delta = _dispatch_timeout(when);\n    if (delta == 0) {\n        return dispatch_async_f(queue, ctxt, func);\n    }\n\n    ds = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);\n    dispatch_assert(ds);\n\n    datc = malloc(sizeof(*datc));\n    dispatch_assert(datc);\n    datc->datc_ctxt = ctxt;\n    datc->datc_func = func;\n    datc->ds = ds;\n\n    dispatch_set_context(ds, datc);\n    dispatch_source_set_event_handler_f(ds, _dispatch_after_timer_callback);\n    dispatch_source_set_timer(ds, when, DISPATCH_TIME_FOREVER, 0);\n    dispatch_resume(ds);\n}\n```\n首先将延迟执行的 block 封装在 `_dispatch_after_time_s` 这个结构体中，并且作为上下文，与 timer 绑定，然后启动 timer。\n到时以后，执行 `_dispatch_after_timer_callback` 回调，并取出上下文中的 block:\n```objc\nstatic void _dispatch_after_timer_callback(void *ctxt) {  \n    struct _dispatch_after_time_s *datc = ctxt;\n    _dispatch_client_callout(datc->datc_ctxt, datc->datc_func);\n    // 清理工作\n}\n```\n\n### performSelector:withObject:afterDelay:\n\n**函数声明：**\n```objc\n- (void)performSelector:(SEL)aSelector \n             withObject:(id)anArgument \n             afterDelay:(NSTimeInterval)delay;\n```\n\n**参数解析：**\naSelector: 使用`Selector`将被调用的方法。该方法没有返回值，参数是id类型或者没有参数。\nanArgument: 方法被调用的时候传递给方法的参数，如果方法没有参数，传nil。\ndelay: 方法被调用之前等待的最小时间。指定为0，方法可能不会被立即执行。方法会在当前线程的runloop循环中排队并尽可能快的被执行。\n\n**讨论：**\n该方法在当前线程的runloop上设置一个定时器来执行`aSelector`。定时器默认在`NSDefaultRunLoopMode`模式下执行。当时间到时，当前线程尝试从runloop队列中取出这个方法并执行。如果runloop处于`NSDefaultRunLoopMode`模式下，方法顺利被执行，否则定时器一直等到runloop处于`NSDefaultRunLoopMode`下才执行。\n我们可以使用`performSelector:withObject:afterDelay:inModes:`方法来指定定时器在哪些mode下执行。\\\n使用`performSelectorOnMainThread:withObject:waitUntilDone:`和`performSelectorOnMainThread:withObject:waitUntilDone:modes:`方法来确保在主线程中执行。\\\n使用`cancelPreviousPerformRequestsWithTarget:`和`cancelPreviousPerformRequestsWithTarget:selector:object:`方法来取消特定的任务。\\\n**注意：**该方法的执行依赖于runloop，子线程默认情况下并不开启runloop，如果你需要在这种情况下使用延迟功能，应当考虑是否开启runloop，还是使用dispatch_after来实现。\n\n### 参考\n\n[深入理解GCD](https://bestswifter.com/deep-gcd/#dispatch_after)\n[performSelector:withObject:afterDelay:](https://developer.apple.com/documentation/objectivec/nsobject/1416176-performselector)\n\n### 最后\n本博客没有做评论系统，如果您对文章有意见，请到[关于我](http://riverli.me/about/)页面获取我的联系方式。\n另外，如果您觉得本文对你有帮助，可以友情给予鼓励，谢谢！\n![微信扫码赏赞](https://ws1.sinaimg.cn/mw690/d3681d85ly1fq0faf7eimj20u00u0q3t.jpg)","tags":["iOS"]},{"title":"2018年度计划","url":"/2018/03/04/2018年度计划/","content":"\n![未来](http://ww1.sinaimg.cn/mw690/d3681d85ly1fp0w9ptid1j20p00gdh9x.jpg)\n\n###生活\n今年可能是我生活变化最大的一年，我结婚了。2018年2月14日，我和我的女朋友领证。婚姻意味着自己不能洒脱不计后果的生活了，身上莫名的多了一份责任，有时候不自觉的去考虑家庭、房子、车子、父母、孩子这些问题，有时候会莫名的沮丧，压力好大，有时候莫名的充满激情，生活真美好。不知道是自己年纪大了，还是怎地，以前只会不顾后果的干，现在却考虑考虑，犹豫犹豫。不管怎样，生活对于我已经不薄了，我把最爱的女朋友变成了老婆。18年，我不希望生活有巨大的改变，稳稳当当的度过我这一年就好。当然还是要定一些小目标。\n<!--more-->\n- 5月1号顺利举行婚礼。\n- 拿到驾照。\n- 带老婆旅游，七天\n- 养成良好的作息，适当健身。\n  - 早：7点，晚:12点\n- 多联系父母，陪父母说说话。\n\n###工作\n17年工作还算顺利，基本上完成了去年定的目标。做了两款产品，有成功，有失败。从产品的角度来讲，给我深刻的体会是：\"越简单的东西，越容易被用户认可，但凡需要用户去理解的规则都会将一部分用户阻于你的App之外\"。我的主要工作还是开发，对产品的思考仅是站在自己参与的项目对考虑的。去年工作中也有很多不足之处，主要体现在开发效率太低，一头扎进了项目，做了很多重复性工作。情绪管理不当，与同事发生了冲突。所以，今年我的主要目标也就是这两个，提升开发效率，让自己变得职场化。\n\n###提升工作效率\n目前我对提升工作效率的思考还是比较浅显，希望在年底的时候能够写一篇提高工作效率的实践化总结。这里简单列取几个点：\n- 做好工作计划。\n- 利用工具。\n- 代码复用率。\n\n###职场化\n职场化是我一直比较反感的话题，错误的职场化会让自己变成会偷懒的“老油条”，目前我还无法接受自己在将来变成“油腻的职场老油条”。但是职场上的成功并不是靠自己技术多牛完成的，我想没有谁能够自己的说，这公司离了我就没法运转了，除非你是老板。 所以还是需要提高自己的职业素养来进一步增强自己的价值。 我所理解的职场化应该是，正确的和同事沟通，恰当的情绪管理，合理的向领导提出建议和要求。实话实说，直来直去可以说为率真，但在职场上是没情商的体现。这方面我欠缺的很多，情绪管理不当，不会向领导提要求等等。在这一年我会关注和反省自己的职场行为。\n\n###学习\n作为软件工程师，学习是我们永远无法绕过的话题。18年开场，直播答题大火，区块链大火。作为一个从事互联网行业的人，有时候会很迷茫，区块链火了，我该怎么办，要不要去学一下啊，前段时间老板和CTO在公司内部做了区块链的分享，我思考了很久，也看了很多资料，目前我依然不知道用这玩意到底能出来什么，虽然目前有很多区块链的应用，但我自己还是想不出来，我能用它做什么… 可能我笨吧… 话说回来，我今年要学什么。我今年打算把学习的精力放在计算机基础知识上，如下：\n\n- 计算机网络\n  - TCP/TP\n- 算法与数据结构\n- 操作系统\n- C/C++\n  - 为什么学习这个，了解我的朋友知道，我是从事iOS开发的，深入iOS系统，学习C还是非常必要的。当然我不会抱着入门指南去学习，我会以源码项目的方式学习。\n- 源码阅读。\n\n当然，除了这些我还打算学点其他方面的知识。\n\n- 理财\n- 品茶\n\n### 读书\n\n读书是不可避免的，我打算做一份书单，长期维护。书单里的书必须是自己读过，思考过的。\n\n###最后\n\n送自己一句话：\"路长道且阻，请奋力前行！\"","tags":["总结与计划"],"categories":["计划总结"]},{"title":"iOS电池相关API","url":"/2018/02/09/i电池相关API/","content":"# iOS电池相关API\n\niOS系统中关于电池的Api较少，据本人了解目前仅有两种电视相关的Api，一种是电量状态，一种是电池状态。\n\n## 开启电池监听\n\n在使用电池相关API的时候需要先开启电池监听，开启代码如下：\n\n```swift\nUIDevice.current.isBatteryMonitoringEnabled = true\n```\n<!--more-->\n## 获取电池状态\n\n```swift\nprint(UIDevice.current.batteryLevel);\nprint(UIDevice.current.batteryState);\n```\n\n**batteryLevel** 表示电量信息，取值范围是0~1.0，如果获取的值为-1,则表示当前电池状态为未知，如：在模拟器上运行代码。\n\n**batteryState** 表示电池状态，是一个枚举类型，如下：\n\n```swift\npublic enum UIDeviceBatteryState : Int {   \n    case unknown\t//电池状态未知\n    case unplugged // 电池未连接充电器，处于放电状态\n    case charging // 电池已经连接了充电器，但并没有充满。\n    case full // 电池已经连接了充电器，并且已经充满。\n}\n```\n\n## 监听电池状态\n\n系统为我们提供了两个通知，方便我们去监听电池状态的变化。分别是：**UIDeviceBatteryLevelDidChange** 和 **UIDeviceBatteryStateDidChange**。 使用方式如下：\n\n```swift\nfunc adBatteryObserver() {\n\tNotificationCenter.default\n            .addObserver(self,\n                         selector: #selector(batteryLevelDidChange(notify:)),\n                         name: NSNotification.Name.UIDeviceBatteryLevelDidChange,\n                         object: nil)\n        NotificationCenter.default\n            .addObserver(self,\n                         selector: #selector(batteryStateDidChange(notify:)),\n                         name: NSNotification.Name.UIDeviceBatteryStateDidChange,\n                         object: nil)        \n}\n\n@objc func batteryLevelDidChange(notify:Notification) {\n  self.textLabel2.text = \"当前电量为：\" + String(UIDevice.current.batteryLevel);\n}\n    \n@objc func batteryStateDidChange(notify:Notification) {\n    self.textLabel2.text = \"当前电量为：\" + String(UIDevice.current.batteryLevel);\n    switch UIDevice.current.batteryState {\n    case .charging:\n        self.textLabel.text = \"charging\"     \n        break\n    case .unknown:\n        self.textLabel.text = \"unknown\"      \n        break\n    case .unplugged:\n        self.textLabel.text = \"unplugged\"    \n        break\n    case .full:\n        self.textLabel.text = \"full\"        \n        break\n    }\n}\n```\n\n## 小结\n\n以上就是iOS电池相关的API，如有遗漏欢迎补充。","tags":["iOS"]},{"title":"WKWebView使用小感","url":"/2018/01/31/WKWebView使用小感/","content":"## 前言\nApple 在iOS8上发布了WKWebView, 旨在替代UIWebView, 然后到目前为止在WKWebView的使用上依然有很多坑。本文主要记录一下最近关于WKWebView使用上的一些感想。欢迎读者留言并讨论，共同提高我们的开发效率。\n\n## WKWebView的优势\n- 相比较于UIWebView其更加高效，内存占有率更低。\n- 比较方便的实现滑动返回功能。\n- 在JS代码注入方法，特别是向Frame里面注入JS有较高的优势。\n<!--more-->\n## 基本使用方法\n关于WKWebView的使用这里不再一一细讲，网络上有很多关于它的使用教程，这个简要介绍一些相关注意点：\n### 进度条\n通过监听estimatedProgress可以实现进度条相关的功能。\n```\n    [self.wkWebView addObserver:self forKeyPath:@\"estimatedProgress\" options:NSKeyValueObservingOptionNew context:nil];\n```\n### 退出ViewController之后网页音视频依然在播放\n产生这个问题的原因是WebView在Vc退出之后并没有立即释放，我的解决方法是在viewDidDisappear方法里调用WKWebview的reload方法。\n\n## 与JS交互\nWKWebView与js交互相关包括：\n- 注入js\n- js调用native\n- native调用js\n\n### 注入js\n```\nWKUserScript *us = [[WKUserScript alloc] initWithSource:@\"js content text\" injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];\n[configuration.userContentController addUserScript:us];\n\n```\n其中WKUserScriptInjectionTimeAtDocumentStart表示在Document加载之前就注入js, 第三个参数表示释放只在主frame里注入js。\n### js调用native\n**注册js方法**\n```\n[self.webViewConfig.userContentController addScriptMessageHandler:self name:@\"setUrlFilter\"];\n```\n**响应js方法**\n```\n// 实现WKScriptMessageHandler 协议\n-(void)userContentController:(WKUserContentController *)userContentController\n     didReceiveScriptMessage:(WKScriptMessage *)message {\n     if (StringEqualInsensitive(message.name, @\"setUrlFilter\")) {\n        [self setUrlFilter:message];\n    }\n}\n- (void)setUrlFilter:(WKScriptMessage *)message {\n    dispatch_async(dispatch_get_main_queue(), ^{\n\n    });\n}\n```\n### native调用js\n```\n[self.wkWebView evaluateJavaScript:@\"window.getFavicon()\" completionHandler:^(id _Nullable obj, NSError * _Nullable error) {\n    }];\n```\n\n## 自定义NSURLProtocol\n首先让wkwebview支持NSURLProtocol可以参考这个库[github](https://github.com/Yeatse/NSURLProtocol-WebKitSupport)\n虽然作者通过hook的方式能实现拦截HTTP请求，但自定义NSURLProtocol缺造成了cookie丢失，post请求Body丢失的问题。对于一些简单的应用，可以通过产品上的一些方案避免这两个问题，但对于一些访问全网类应用，这两个问题却是致命的。\n\n另外，有一种解决post，body丢失的方法是通过[hook-ajax](https://github.com/wendux/Ajax-hook)请求，让网页的请求通过客户端来方法。\n\n\n## Crash\n我自己通过实现自定义NSURLProtocol来实现拦截特定的请求，但是在使用过程中发了频繁的崩溃，不知道是我使用有误还是框架原因，哪位读者朋友知道原因，希望不吝赐教。最后我放弃了自定义NSURLProtocol，崩溃日志如下：\n![崩溃信息](https://ws3.sinaimg.cn/large/006tNc79ly1fnrsmkzlm5j31kw0t9hdt.jpg)\ngithub上有一个相关的问题，将webView的ProcessPool设为单例，但这个做法并没有解决我的问题。相关连接[webview crash](https://github.com/Yeatse/NSURLProtocol-WebKitSupport/issues/2)\n\n\n## 内容拦截\n对于一些可访问全网信息的App，可能会涉及到拦截特定的网页或者广告，类似这样的需求在iOS11之前基本无法实现，因为通过实现NSURLProtocol来拦截指定的网页，会造成Cookie无法共享，POST方法Body丢失，以及莫名奇妙的Crash。但在iOS11之后，Apple开放了WKContentRuleListStore接口，我们可以使用它来限制不想访问的信息，如，广告。具体使用如下：\n```\nNSString *jsonPath = [[NSBundle mainBundle] pathForResource:@\"contentRuleList\" ofType:@\"json\"];\nNSString *jsonString = [NSString stringWithContentsOfFile:jsonPath encoding:NSUTF8StringEncoding error:nil];\nif (@available(iOS 11.0, *)) {\n    [[WKContentRuleListStore defaultStore] compileContentRuleListForIdentifier: @\"qccastRemoveAd\" encodedContentRuleList: jsonString         completionHandler:^(WKContentRuleList *contentRuleList, NSError *error) {\n        if(error == nil) {\n            [self.wkWebView.configuration.userContentController addContentRuleList:rulelist];\n        }\n    }];\n}\n```","tags":["iOS"]},{"title":"iOS屏幕适配","url":"/2017/12/31/iOS屏幕适配/","content":"## 适配的关键\n\n对于大多数开发者而言，UI的开发流程是：设计师出图 ->还原设计师效果图。问题是：设计师一般只会给一套设计图，基于6或者6p，其他设备上的显示信息需要开发者自己去做调整。所以个人觉得还原设计图之前要与设计师进行充分的沟通，在不同屏幕上，字体、元素宽高，元素间距等信息如何处理。只有你们定好了规范，你才能在不同的屏幕上做到还原设计师的设计意图，而不会重复返工修改UI。\n\n## 屏幕适配包含哪些内容\n\n- 字体适配\n- 距离适配\n- 图片适配\n\n<!--more-->\n## iPhone 设备屏幕信息\n\n下图展示了从初代iPhone到iPhoneX的屏幕信息。\n\n![iPhone屏幕信息](http://ww1.sinaimg.cn/mw690/d3681d85ly1fmzoco6jeej20lq0my40z.jpg)\n\n你可以在[这个](https://www.paintcodeapp.com/download/poster_iphones.pdf)下载到PDF格式。\n\n接下来介绍关于适配的几个概念。\n\n## point 点\n\n我们开发过程中常用的单位就是点。在早期iOS系统中一个点就是一个像素。\n\n## Pixel 像素\n\n随着屏幕技术的提升，1个点所表示的像素数也越来越多，清晰度也越来越高。iOS中通过**UIScreen.mainScreen.scale** 可以获取当前设备的缩放因子，如果该值为2，则一个点表示4个像素，该值为3，则一个点表示9个像素。\n\n## PPI\n\n每英寸所拥有的像素数目。\n\n## 适配原理\n\n![PPI放大过程](http://ww1.sinaimg.cn/mw690/d3681d85ly1fmztpx82ouj20ug0bm407.jpg)\n\n我们来假设：设计师给的设计图是基于4.7英寸的设备。所以，相对5.5英寸是扩大了1.17倍，对于4英寸的设备缩小到0.875倍。由于目前市面上基本上已经没有了3.5英寸的设备了，并且4英寸和3.5英寸的屏幕宽度都是320，所以我们就在3.5英寸的设备上直接显示4英寸上的内容，不做缩放。这样一来，只剩下了iPhone X。对于iPhone X而言，由于其相对于4.7英寸的设备而言只是高度增加了，这是暂时让其与4.7英寸的屏幕保持一致，只需根据具体的页面信息来调整其高度信息。\n\n","tags":["iOS"]},{"title":"iOS_Run_Loop事件监听","url":"/2017/12/31/iOS_Run_Loop事件监听/","content":"## Run Loop监听事件列表\n\n1. run loop的入口事件。\n2. run loop即将处理计时器事件。\n3. run loop即将处理输入源事件。\n4. run loop即将休眠。\n5. run loop已经被唤醒，但是还没有处理唤醒它的事件。\n6. run loop 退出。\n\n<!--more-->\n\n## 监听代码\n\n```objective-c\n- (void)threadMain\n{\n    NSRunLoop* myRunLoop = [NSRunLoop currentRunLoop];\n    CFRunLoopObserverContext context = {0,\n        (__bridge void *)(self), NULL, NULL, NULL};\n    CFRunLoopObserverRef    observer = CFRunLoopObserverCreate(kCFAllocatorDefault,\n                                                               kCFRunLoopAllActivities, YES, 0, &myRunLoopObserver, &context);\n    \n    if (observer)\n    {\n        CFRunLoopRef    cfLoop = [myRunLoop getCFRunLoop];\n        CFRunLoopAddObserver(cfLoop, observer, kCFRunLoopDefaultMode);\n    }\n    \n    [NSTimer scheduledTimerWithTimeInterval:0.1 target:self\n                                   selector:@selector(doFireTimer:) userInfo:nil repeats:YES];\n    \n    NSInteger    loopCount = 10;\n    do\n    {\n        [myRunLoop runUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];\n      // 1s 后才执行 --操作\n        loopCount--;\n    }\n    while (loopCount);\n}\n\nstatic void myRunLoopObserver(CFRunLoopObserverRef observer,  CFRunLoopActivity activity, void *info)\n{\n    switch (activity) {\n        case kCFRunLoopEntry:\n            NSLog(@\"kCFRunLoopEntry\");\n            break;\n        case kCFRunLoopBeforeTimers:\n            NSLog(@\"kCFRunLoopBeforeTimers\");\n            break;\n        case kCFRunLoopBeforeSources:\n            NSLog(@\"kCFRunLoopBeforeSources\");\n            break;\n        case kCFRunLoopBeforeWaiting:\n            NSLog(@\"kCFRunLoopBeforeWaiting\");\n            break;\n        case kCFRunLoopAfterWaiting:\n            NSLog(@\"kCFRunLoopAfterWaiting\");\n            break;\n        case kCFRunLoopExit:\n            NSLog(@\"kCFRunLoopExit\");\n            break;\n            \n        default:\n            break;\n    }\n}\n\n- (void)doFireTimer:(NSTimer *)timer {\n    NSLog(@\"timer action\");\n}\n```\n\n**解释：**threadMain方法是apple官方文档中的示例代码，接下来主要讲解里面的几个主要函数。\n\n**CFRunLoopActivity** 监听事件\n\n```objective-c\ntypedef enum CFRunLoopActivity : CFOptionFlags {\n    kCFRunLoopEntry = (1UL << 0),\n    kCFRunLoopBeforeTimers = (1UL << 1),\n    kCFRunLoopBeforeSources = (1UL << 2),\n    kCFRunLoopBeforeWaiting = (1UL << 5),\n    kCFRunLoopAfterWaiting = (1UL << 6),\n    kCFRunLoopExit = (1UL << 7),\n    kCFRunLoopAllActivities = 0x0FFFFFFFU\n} CFRunLoopActivity;\n```\n\n**CFRunLoopObserverContext**是一个结构体\n\n````objective-c\ntypedef struct {\n    CFIndex\tversion;\n    void *\tinfo;\n    const void *(*retain)(const void *info);\n    void\t(*release)(const void *info);\n    CFStringRef\t(*copyDescription)(const void *info);\n} CFRunLoopObserverContext;\n````\n\nversion: 结构体的版本号，必须是0\n\nretain: 对info进行retaion操作的回调方法。\n\nrelease: 对info进行release操作的回调方法。\n\ncopyDescription: 对info进行copyDescription操作的回调方法。\n\ninfo:  由程序定义的一个指针，在创建的时候与run loop的监听者相关联。这个指针在context内部的所有回调函数中传递。\n\n**CFRunLoopObserverCreate** 创建run loop监听者对象。\n\n```objective-c\nCFRunLoopObserverRef CFRunLoopObserverCreate(CFAllocatorRef allocator, \n                                             CFOptionFlags activities, \n                                             Boolean repeats, \n                                             CFIndex order, \n                                             CFRunLoopObserverCallBack callout, \n                                             CFRunLoopObserverContext *context);\n```\n\nallocator: 内存分配器，为新的对象分配内存，NULL或kCFAllocatorDefault表示默认的内存分配器。\n\nactivities: 要监听那些事件。参考：CFRunLoopActivity。\n\nrepeats： 是否重复监听。\n\ncallout: 回调函数。\n\ncontext: 上下文，参考：CFRunLoopObserverContext\n\n**runUntilDate** 执行run loop直到一个指定时间。在这段时间内处理所有依附于它的输入源的数据。如果没有输入源或者时间源依附于run loop, 这个方法将立即退出，否则的话，他将以NSDefaultRunLoopMode 为参数不停的调用**runMode: beforeDate:**一直到指定的时间。\n\n手动的从run loop中移除所有的输入源和timer不能确保run loop会终止。macOS 可以根据需要装载和移除额外的输入源，以处理针对接收者线程的请求，这些源可以阻止运行循环退出。\n\n## 监听主线程Run Loop事件\n\n对于主线程而言，run loop 随着应用程序的启动而启动，我们无法控制其启动和退出。我们可以对其运行状态监听。\n\n在**didFinishLaunchingWithOptions**方法中调用**threadMain**，会发现控制台在不断的打印数据。\n\n需要注意的是：对于主线程而言**threadMain**方法中while不是必须的，因为程序运行期间，主线程的run loop不会终止。\n\n## 监听后台线程Run Loop事件\n\n在**didFinishLaunchingWithOptions**方法中调用\n\n```objective-c\n[self performSelectorInBackground:@selector(threadMain) withObject:nil];\n```\n\n会发现控制台会打印100次 **timer action**，这100次来自于10次循环*每秒10调用timer。\n\n## 小结\n\n这篇文章主要讲解了关于Run Loop的事件监听，Run Loop是iOS开发和面试中经常出现的知识点，我也在进一步的学习，如果有哪些不对的地方，还希望您的指正。","tags":["runloop"]},{"title":"Xcode9 重构功能","url":"/2017/11/19/Xcode9 重构功能/","content":"\n\n今天聊一下Xcode9中关于代码重构功能的一些使用，可以方便我们更加高效的书写或者修改代码。\n\n**重构功能所在的位置：**\n\n**Editor->Refactor**\n\n![](http://ww1.sinaimg.cn/large/d3681d85ly1flnqm3qjxnj20ro0gwdiu.jpg)\n\n<!--more-->\n\n## 重命名\n\n按住**command**，并点击要重命名的内容，如下图，点击rename。\n\n\n\n![](http://ww1.sinaimg.cn/mw690/d3681d85ly1flnqqvu6lxj20h40gmab3.jpg)\n\n或者选中要修改的名字，然后双指(右键)，如下图。\n\n![](http://ww1.sinaimg.cn/mw690/d3681d85ly1flnqt48yqnj21540ekwgm.jpg)\n\n点击**Rename...**\n\n![](http://ww1.sinaimg.cn/mw690/d3681d85ly1flnqw4qdc8j21jw0gcwgj.jpg)\n\n选择要重命名的内容： 所有、代码相关、文件名相关、注释相关、其他\n\n## 导出表达式\n\n选中要导出的内容，比如下图, 可以导出变量、方法。\n\n![](http://ww1.sinaimg.cn/mw690/d3681d85ly1flnr1yigldj20x00p00xf.jpg)\n\n导出方法的结果：\n\n![](http://ww1.sinaimg.cn/mw690/d3681d85ly1flnr4yb0n4j20o80cgwfo.jpg)\n\n导出变量的结果\n\n![](http://ww1.sinaimg.cn/mw690/d3681d85ly1flnr5mcpw9j20mu0840tk.jpg)\n\n你可重新命名方法名和变量名，会一次性修改。\n\n## 各种高效操作\n\n快速添加 if switch 等分支语句\n\n选中if语句，然后按下 **command + shift + A** 可以为方法的添加其他分支。\n\n![](http://ww1.sinaimg.cn/mw690/d3681d85ly1flnra4n5tjj210i0d641j.jpg)\n\n同样对于switch语句\n\n![](http://ww1.sinaimg.cn/mw690/d3681d85ly1flnrevt2wwj20pa0ma0wb.jpg)\n\n## 参考\n\nhttps://talk.objc.io/episodes/S01E59-refactoring-with-xcode-9\n\n","tags":["Xcode"],"categories":["重构"]},{"title":"C数组与指针","url":"/2017/10/08/C数组与指针/","content":"\n## 指针\n\n例子1：\n\n```c\nint a = 5;\nint *p = &a;\nstd::cout << \"a = \" << a << \"\\n\";\nstd::cout << \"&a = \" << &a << \"\\n\";\nstd::cout << \"p = \" << p << \"\\n\";\nstd::cout << \"&p= \" << &p << \"\\n\";\nstd::cout << \"*p= \" << *p << \"\\n\";\n\n/*\n//输出\na = 5\n&a = 0x7fff5fbff63c\np = 0x7fff5fbff63c\n&p= 0x7fff5fbff630\n*p= 5\n*/\n\n//以下两句会报错\n//Cannot take the address of an rvalue of type 'int *'\nstd::cout << \"&&a = \" << &(&a) << \"\\n\";\nstd::cout << \"&&p= \" << &(&p) << \"\\n\";\n```\n<!--more-->\n从例子1中可以看出：\n\n       \t1. 指针是一个变量，其值为另一个变量的地址，即：内存位置的直接地址。\n        \t2. p是一个指针变量，其值是变量a的地址。\n         \t3. &是取地址符。\n         \t4. \\* 取回指针变量所指定地址的变量的值。\n\n##  指针与一维数组\n\n例子2：\n\n```c\nint a[3] = {1, 2, 3}; \n\nstd::cout << \"a = \" << a << \"\\n\";\nstd::cout << \"&a[0] = \" << &a[0] << \"\\n\";\nstd::cout << \"a[0] = \" << a[0] << \"\\n\";\nstd::cout << \"*a = \" << *a << \"\\n\";\n/*\n//输出\na\t= 0x7fff5fbff62c\n&a[0]\t= 0x7fff5fbff62c\na[0] = 1\n*a = 1\n*/\n\nint *p = a;\nstd::cout << \"p = \" << p << \"\\n\";\nstd::cout << \"*p = \" << *p << \"\\n\";\nstd::cout << \"*(p+1) = \" << *(p+1) << \"\\n\";\nstd::cout << \"*(p+2) = \" << *(p+2) << \"\\n\";\n\n/*\n//输出\np = 0x7fff5fbff62c\n*p = 1\n*(p+1) = 2\n*(p+2) = 3\n*/\n```\n\n\n\n从上面代码可以看出：\n\n1. 一维数组的变量名的值是该数组第一个元素的地址。\n\n## 指针与二维数组\n\n![二维数组示意图](http://ww1.sinaimg.cn/large/d3681d85ly1fka47a0p2kj20qo09e0sy.jpg)\n\n```c\nint a[3][4] = {\n    {1, 2, 3, 4},\n    {5, 6, 7, 8},\n    {9, 10, 11, 12}\n};\nstd::cout << \"a = \" << a << \"\\n\";\nstd::cout << \"a[0] = \" << a[0] << \"\\n\";\nstd::cout << \"&a[0][0] = \" << &a[0][0] << \"\\n\";\nstd::cout << \"a[0][0] = \" << a[0][0] << \"\\n\";\n\n/*\na = 0x7fff5fbff600\na[0] = 0x7fff5fbff600\n&a[0][0] = 0x7fff5fbff600\na[0][0] = 1\n*/\n\nstd::cout << \"sizeof(a) = \" << sizeof(a) << \"\\n\";\nstd::cout << \"sizeof(a[0]) = \" << sizeof(a[0]) << \"\\n\";\n\n/*\nsizeof(a) = 48\nsizeof(a[0]) = 16\n*/\n\nint (*p)[4] = a;\nstd::cout << \"p = \" << p << \"\\n\";\nstd::cout << \"p[0] = \" << p[0] << \"\\n\";\nstd::cout << \"*p[0] = \" << *p[0] << \"\\n\";\n\n//将二维转为一维\nint *b = (int *)a;\nstd::cout << \"b = \" << b << \"\\n\";\nstd::cout << \"*b = \" << *b << \"\\n\";\nstd::cout << \"*(b+1) = \" << *(b+1) << \"\\n\";\nstd::cout << \"*(b+2) = \" << *(b+2) << \"\\n\";\n//通过一维数组访问二维数组中的i行n列\n*(b + i*rowCount + n);\n\n\n//参数\n// int *b = (int *)a;\n// test(b, 3, 4);\nvoid test(int *a, int row, int column);\n// test(a, 3, 4);\nvoid test(int a[][4], int row, int colum);\n// 错误\nvoid test(int **a, int row, int column);\n```\n\n1. 在二维数组中，数组名a，a[0]的值都是第一个元素a\\[0\\]\\[0\\]的地址。\n2. 二维数组在内存中也是按顺序排列的。\n3. 二维数组在C语言中是一维数组，且每个元素又指向一个一维数组。\n\n## demo\n\n[百度云盘](https://pan.baidu.com/s/1gfeUHMz)\n\n# 参考\n\n[理解lvalue和rvalue](http://blog.csdn.net/rogerhe/article/details/6410993)\n\n[指针变量、普通变量、内存和地址的全面对比](http://www.cnblogs.com/douzi2/p/5087892.html)\n\n《C和指针》","tags":["C"]},{"title":"java-控制台输出乱码问题","url":"/2017/10/06/java-控制台输出乱码问题/","content":"\n# 问题描述\n在工作中遇到这么一个问题，需要将一个巨复杂的常量值到印出来，但是定义的过程中有很多Unicode，输出到控制台都是乱码，使用了很多方法都无法解决，最后使用了commons-lang-2.6这个库解决了。这个库提供了一堆工具类供使用。\n<!--more-->\n# 解决方法\n```java\nStringEscapeUtils.escapeJava(WEB_URL.toString());\n```\n\n## 交流群\n移动开发交流群：264706196\n","tags":["java"]},{"title":"iOS 正确控制导航leftBarButtonItems的姿势","url":"/2017/10/02/iOS 正确控制导航leftBarButtonItems的姿势/","content":"\n## leftBarButtonItems 结构分析\n\n### 层级结构\n\n我看了对比了iOS9 和iOS 11的层级结构，如下：\n\n![iOS9](http://ww1.sinaimg.cn/large/006h0fcHly1fk1le2ecrdj30bq04oq3f.jpg)\n<!--more-->\n\n\n![iphone 7 iOS 11](http://ww1.sinaimg.cn/large/006h0fcHly1fk1m997pmtj30b805lmxp.jpg)\n\n可以看出，iOS11 之后NavigationBar的层级发生了较大变化。\n\n### 结论\n\n通过比较，我发现如下结论：\n\n1. 默认情况下，在320、375宽度的屏幕上，第一个按钮距离屏幕左边界的宽度是16，在414第一个按钮距离屏幕左边界的宽度是20。\n2. 默认情况下，在320、375宽度的屏幕上，BarButtonItems之间的间距是8，在414宽度的屏幕上，BarButtonItems之间的间距是10。\n3. iOS11 , 所有Items都包括在 **_UIButtonBarStackView** 下，控制它的X坐标即可控制左边距。\n4. iOS9，所有Item都在NavigationBar下，统计并排，所以控制左边距，只需要控制第一个元素的左边距。\n\n## 需求自定义距屏幕左边距\n\n我的做法很粗暴，直接去修改上面结论的坐标，步骤如下：\n\n1. 自定义UINavigationBar.\n2. 重写(void)drawRect:(CGRect)rect;\n3. 调用。\n\n```objective-c\n@interface CustomUINavigationBar : UINavigationBar\n@property (nonatomic,assign) CGFloat leftValue;\n@end\n\n@implementation CustomUINavigationBar\n\n- (void)drawRect:(CGRect)rect {\n    [super drawRect:rect];\n    \n    if ([UIDevice currentDevice].systemVersion.floatValue >= 11.0) {\n        for (UIView *view in self.subviews) {\n            for (UIView *subView in view.subviews) {\n                if ([NSStringFromClass(subView.class) isEqualToString:@\"_UIButtonBarStackView\"]) {\n                    subView.frame = CGRectMake(self.leftValue, subView.frame.origin.y, subView.frame.size.width, subView.frame.size.height);\n                }\n            }\n        }\n    }else{\n        for (int i=0; i<self.subviews.count; i++) {      \n            UIView *t_view = self.subviews[i];\n            if (i==0) {\n                t_view.frame = CGRectMake(self.leftValue, t_view.frame.origin.y, t_view.frame.size.width, t_view.frame.size.height);\n            }\n        }\n    }\n}\n@end\n```\n\n注： 以上代码只适合leftBarButtonItems中只有一个元素的情况下。因为在多个元素的情况下，iOS10之前，items是平级的，直接在NavigationBar下，修改第一个元素无法修改第二个元素之后元素的坐标。\n\n## 需求多个元素情况下距左边距\n\n```objective-c\n@implementation CustomUINavigationBar\n\n- (void)drawRect:(CGRect)rect {\n    [super drawRect:rect];\n    \n    if ([UIDevice currentDevice].systemVersion.floatValue >= 11.0) {\n        for (UIView *view in self.subviews) {\n            for (UIView *subView in view.subviews) {\n                if ([NSStringFromClass(subView.class) isEqualToString:@\"_UIButtonBarStackView\"]) {\n                    subView.frame = CGRectMake(self.leftValue, subView.frame.origin.y, subView.frame.size.width, subView.frame.size.height);\n                }\n            }\n        }\n    }else{\n        for (int i=0; i<self.subviews.count; i++) {\n            \n            UIView *t_view = self.subviews[i];\n            if (i==0) {\n                t_view.frame = CGRectMake(self.leftValue, t_view.frame.origin.y, t_view.frame.size.width, t_view.frame.size.height);\n            }else{\n              // (1)相比前一段代码，多了如下几行。\n                if (SCREEN_WIDTH == 414) {\n                        t_view.frame = CGRectMake(t_view.frame.origin.x-20+self.leftValue, t_view.frame.origin.y, t_view.frame.size.width, t_view.frame.size.height);\n                }else{\n                        t_view.frame = CGRectMake(t_view.frame.origin.x-16+self.leftValue, t_view.frame.origin.y, t_view.frame.size.width, t_view.frame.size.height);\n                }\n            }\n            \n        }\n    }\n}\n@end\n```\n\n注：请看注释(1)。为什么要对屏幕宽度判断，请参考结论1。\n\n## 需求多个元素情况下，自定义items间的距离\n\n1. iOS 9\n\n   ![ios9 层级结构](http://ww1.sinaimg.cn/large/006h0fcHly1fk1kzj6c7vj308202daa4.jpg)\n\n   如上图所示：计算items之间的元素距离就是计算b,的x坐标位置。\n\n   ​\n\n2. iOS 11\n\n   ![iOS 11](http://ww1.sinaimg.cn/large/006h0fcHly1fk1l36u5z0j3096067wf3.jpg)\n\n   如上图, 通过Xcode可以看出UIView(b)的宽度，坐标刚好符合 a c 之间的间隔，但是通过修改b的宽度确实无法实现修改items之间的间隔。只能通过修改 **_UITAMICAdaptorView**的x坐标来改边items之间的间距。\n\n3. 具体使用\n\n```objective-c\n//1. 使用自定义的NavigationBar\nUINavigationController *nav = [[UINavigationController alloc] initWithNavigationBarClass:[CustomUINavigationBar class] toolbarClass:nil];\n    ViewController *vc = [[ViewController alloc] init];\n    [nav setViewControllers:@[vc]];\n    self.window.rootViewController = nav;\n\n//2. 在设置完leftItems之后设置距离左边的距离，或者items之间的间距\n/*..your setting..*/\nself.navigationItem.leftBarButtonItems = @[leftBar, leftBar1];\nCustomUINavigationBar *navbar = (CustomUINavigationBar *)self.navigationController.navigationBar;\nnavbar.leftValue = 10;\n[navbar setItemsSpace:0];\n```\n\n4. 最终代码\n\n```objective-c\n@interface CustomUINavigationBar : UINavigationBar\n@property (nonatomic,assign) CGFloat leftValue;\n- (void)setItemsSpace:(CGFloat)space;\n@end\n\n#define SCREEN_WIDTH [UIScreen mainScreen].bounds.size.width\n@interface CustomUINavigationBar()\n@property (nonatomic, assign)CGFloat spaceBetweenItems;\n@end\n\n@implementation CustomUINavigationBar\n\n- (instancetype)init\n{\n    self = [super init];\n    if (self) {\n        self.spaceBetweenItems = -1024;\n    }\n    return self;\n}\n\n- (void)drawRect:(CGRect)rect {\n    [super drawRect:rect];\n    \n    if ([UIDevice currentDevice].systemVersion.floatValue >= 11.0) {\n        for (UIView *view in self.subviews) {\n            for (UIView *subView in view.subviews) {\n                if ([NSStringFromClass(subView.class) isEqualToString:@\"_UIButtonBarStackView\"]) {\n                    \n                    NSInteger count = 0;\n                    for(int i= 1; i<subView.subviews.count; i++) {\n                        UIView *t_subview = subView.subviews[i];\n                        if ([NSStringFromClass(t_subview.class) isEqualToString:@\"_UITAMICAdaptorView\"] ) {\n                            count ++;\n                            if (SCREEN_WIDTH == 414) {\n                                t_subview.frame = CGRectMake(t_subview.frame.origin.x - (10-self.spaceBetweenItems), t_subview.frame.origin.y, t_subview.frame.size.width, t_subview.frame.size.height);\n                            }else{\n                                t_subview.frame = CGRectMake(t_subview.frame.origin.x - (8-self.spaceBetweenItems), t_subview.frame.origin.y, t_subview.frame.size.width, t_subview.frame.size.height);\n                            }\n                        }\n                    }\n                    \n                    if (SCREEN_WIDTH == 414) {\n                        subView.frame = CGRectMake(self.leftValue, subView.frame.origin.y, subView.frame.size.width - (count-1)*(10 - _spaceBetweenItems), subView.frame.size.height);\n                    }else{\n                        subView.frame = CGRectMake(self.leftValue, subView.frame.origin.y, subView.frame.size.width - (count-1)*(8 - _spaceBetweenItems), subView.frame.size.height);\n                    }\n                    \n                    \n                }\n            }\n            \n        }\n    }else{\n        for (int i=0; i<self.subviews.count; i++) {\n            \n            UIView *t_view = self.subviews[i];\n            NSString *class = NSStringFromClass(t_view.class);\n          //_UINavigationBarBackIndicatorView 通过层级结构可以看出有这个view, 在这个不做任何修改，保持系统原样。\n            if ([class isEqualToString:@\"_UINavigationBarBackIndicatorView\"]) {\n                return;\n            }\n            if (i==0) {\n                t_view.frame = CGRectMake(self.leftValue, t_view.frame.origin.y, t_view.frame.size.width, t_view.frame.size.height);\n            }else{\n                if (SCREEN_WIDTH == 414) {\n                        t_view.frame = CGRectMake((t_view.frame.origin.x-20+self.leftValue)-(10-self.spaceBetweenItems), t_view.frame.origin.y, t_view.frame.size.width, t_view.frame.size.height);\n                }else{\n                        t_view.frame = CGRectMake((t_view.frame.origin.x-16+self.leftValue) -(8-self.spaceBetweenItems), t_view.frame.origin.y, t_view.frame.size.width, t_view.frame.size.height);\n                }\n            }\n            \n        }\n    }\n}\n\n-(CGFloat)spaceBetweenItems {\n    if (_spaceBetweenItems == -1024) {\n        if (SCREEN_WIDTH == 414) {\n            return 10;\n        } else {\n            return 8;\n        }\n    }else{\n        return _spaceBetweenItems;\n    }\n    \n}\n- (void)setItemsSpace:(CGFloat)space {\n    self.spaceBetweenItems = space;\n}\n```\n\n## 拓展\n\n如果你有兴趣可以继续往下考虑：\n\n1. items间距不一样如何处理？\n2. 能不能使用AOP实现？\n3. 如何进一步封装？\n\n## 参考\n\n[美团齐刘海整理](https://tech.meituan.com/iPhoneX%E5%88%98%E6%B5%B7%E6%89%93%E7%90%86%E6%8C%87%E5%8C%97.html)\n\n\n\n\n\n\n\n\n\n","tags":["APNS"]},{"title":"Xcode 单元测试","url":"/2017/10/01/Xcode 单元测试/","content":"\n## 添加单元测试\n\n**新建项目时添加**\n\n![WX20170928-090158](http://ww1.sinaimg.cn/large/006h0fcHly1fjzkvml5hkj30cy07y3z4.jpg)\n\n**在已有项目中添加**\n<!--more-->\nFile->New->Target...\n\n![WX20170928-090849](http://ww1.sinaimg.cn/large/006h0fcHly1fjzkw4d6raj30k60ebwfj.jpg)\n\n**效果**\n\n![WX20170928-090735](http://ww1.sinaimg.cn/large/006h0fcHly1fjzkwdi57yj30ci068dgy.jpg)\n\n\n\n## 基本流程\n\n单元测试的类继承自：XCTestCase\n\n测试方法以test开头\n\n```swift\n override func setUp() {\n        ////每次测试前调用，可以在测试之前创建在test case方法中需要用到的一些对象等\n        super.setUp()\n    }\n    \n    override func tearDown() {\n        //每次测试结束时调用tearDown方法\n        super.tearDown()\n    }\n    \n    func testExample() {\n       //具体的测试逻辑 \n    }\n```\n\n基本测试流程：\n\n- 定义变量和预期\n- 执行方法得到实际值\n- 断言\n\n常用断言表达式\n\n```swift\n//通用断言\n XCTAssert(expression, format...)\n //常用断言：\n XCTAssertTrue(expression, format...)\n XCTAssertFalse(expression, format...)\n XCTAssertEqual(expression1, expression2, format...)\n XCTAssertNotEqual(expression1, expression2, format...)\n XCTAssertEqualWithAccuracy(expression1, expression2, accuracy, format...)\n XCTAssertNotEqualWithAccuracy(expression1, expression2, accuracy, format...)\n XCTAssertNil(expression, format...)\n XCTAssertNotNil(expression, format...)\n \n XCTFail(format...) //直接Fail的断言\n```\n\n\n\n## 基本的测试\n\n```swift\nfunc testExample() {\n        let a : Int32! = 5\n        let b : Int32! = 10\n        let expected: Int32! = 16;\n        let c:Int32! =  self.add(a: a, b: b)\n        XCTAssertEqual(c, expected, \"add方法错误\");\n}\n```\n\n\n\n## 异步测试\n\n```swift\nfunc testAsyn() {\n    let exp : XCTestExpectation = self.expectation(description: \"出错啦\")\n    let queue: OperationQueue = OperationQueue.init()\n    queue.addOperation {\n        sleep(2)\n        XCTAssertLessThanOrEqual(\"1\", \"1\")\n        exp.fulfill()\n    }\n\n    self .waitForExpectations(timeout: 3, handler: { (error: Error?) in\n        if error != nil {\n            print(\"超时：\\(error.debugDescription)\")\n        }\n    })            \n}\n```\n\n\n\n## 性能测试\n\n```swift\nfunc testPerformanceExample() {\n        //性能测试方法，通过测试block中方法执行的时间，比对设定的标准值和偏差觉得是否可以通过测试\n        self.measure {\n            var i: Int64 = 1\n            var r: Int64 = 1\n            while i < 100000000 {\n                r += i\n                i+=1\n            }\n            print(\"r=\\(r)\")\n        }\n    }\n```\n\n查看结果&调整期望\n\n演示\n\n## 代码覆盖率\n\n配置选项：\n\nProduct->schemes->edit scheme\n\n![WX20170928-091800](http://ww1.sinaimg.cn/large/006h0fcHly1fjzkzcjulbj30nf08ugmy.jpg)\n\n代码覆盖是基于文件查看的：新建一个CodeCoverage.swift 提供一个checkName方法。\n\n测试代码：\n\n```swift\nfunc testCodeCoverage()  {\n\tCodeCoverage.checkName(name: \"riverli\")\n}\n```\n\n查看结果：\n\n![WX20170928-092037](http://ww1.sinaimg.cn/large/006h0fcHly1fjzkztlm0aj30xc06zmza.jpg)\n\n## 基本UI测试\n\n演示","tags":["APNS"]},{"title":"iOS国际化方案","url":"/2017/09/22/iOS国际化方案/","content":"\n# 初始化多语言\n\n在项目PROJECT -> info -> Localizations 添加你想适配的语言。\n\n![](http://ww1.sinaimg.cn/large/d3681d85ly1fjsdf4i6rej20e102pwem.jpg)\n<!--more-->\n\n# info.plist国际化\n\ninfo.plist中包含的项目名称、权限申请相关内容需要国际化：\n\n新建：**InfoPlist.strings**，选择要国际化的语言，如下图所示：\n\n![](http://ww1.sinaimg.cn/large/d3681d85ly1fjscy1u622j20eg03mmxm.jpg)\n\n![](http://ww1.sinaimg.cn/large/d3681d85ly1fjsd3bl30pj20f204umxf.jpg)\n\n在InfoPlist.string 不同的语言里填上相应的内容：\n\n```json\n\"CFBundleName\" = \"\";\n\"CFBundleDisplayName\" = \"\";\n\"NSLocationWhenInUseUsageDescription\" = \"\";\n\"NSCameraUsageDescription\" = \"\";\n\"NSMicrophoneUsageDescription\" = \"\";\n\"NSPhotoLibraryUsageDescription\" = \"\";\n\"NSBluetoothPeripheralUsageDescription\" = \"\";\n\"NSAppleMusicUsageDescription\" = \"\";\n```\n\n关于info.plist中的字段描述可以参考这里：[apple 文档](https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009248-SW1)\n\n# 判断系统是否是中文\n\n我们的项目里，中文(台湾，澳门，繁体)一律显示问简体中文，其他都显示为英文：\n\n```objective-c\ntypedef enum : NSUInteger {\n    LANGUAGE_CN,\n    LANGUAGE_EN,\n    LANGUAGE_OTHER,\n} SYSTEMLANGUAGE;\n\n-(SYSTEMLANGUAGE)systemLn\n{\n    NSString * language = [[NSLocale preferredLanguages] objectAtIndex:0];\n\n    if (StringContains(language, @\"zh-Hant\") ||\n        StringContains(language, @\"zh-Hans\")) {\n        return LANGUAGE_CN;\n    }\n    \n    return LANGUAGE_EN;\n}\n```\n\n\n\n","tags":["国际化"]},{"title":"iOS多个网络请求同步","url":"/2017/06/10/iOS多个网络请求同步/","content":"# 问题描述\n大多数前端开发步骤：\n1. 从服务端获取数据\n2. 数据整理\n3. 填充到界面上\n   在某些特殊的情况下，界面上所需要展示的数据是从多个接口里获取的，并且这些数据相互关联，需要客户端进行处理才能展示给用户。那么这里的问题是：如何知道请求都回来了。\n   问题可简化为：界面刷新的操作需要在接口A，B，C的数据都返回来了才能进行。\n   **注：** 以下使用的网络框架是swift中的Alamofire\n\n<!--more-->\n# 解决方法\n## 方法一 使用GCD和信号量\n\n```swift\n@IBAction func requestNetAction(_ sender: Any) {\n        \n        let group = DispatchGroup();\n        let  queueRequest = DispatchQueue.global();\n        \n        queueRequest.async(group:group){\n            let semaphore = DispatchSemaphore(value: 0);\n            print(\"第1个\")\n            Alamofire.request(\"https://httpbin.org/get\").responseJSON { response in\n                semaphore.signal()\n            }\n            let result = semaphore.wait(timeout: DispatchTime.distantFuture)\n            if(result == DispatchTimeoutResult.success)\n            {\n                print(\"第1个请求回来\")\n            }\n            \n        }\n        \n        queueRequest.async(group:group){\n            let semaphore = DispatchSemaphore(value: 0);\n            print(\"第2个\")\n            Alamofire.request(\"https://httpbin.org/get\").responseJSON { response in\n                semaphore.signal()\n            }\n            let result = semaphore.wait(timeout: DispatchTime.distantFuture)\n            if(result == DispatchTimeoutResult.success)\n            {\n                print(\"第2个请求回来\")\n            }\n        }\n        \n        queueRequest.async(group:group){\n            let semaphore = DispatchSemaphore(value: 0);\n            print(\"第3个\")\n            Alamofire.request(\"https://httpbin.org/get\").responseJSON { response in\n                semaphore.signal()\n            }\n            let result = semaphore.wait(timeout: DispatchTime.distantFuture)\n            if(result == DispatchTimeoutResult.success)\n            {\n                print(\"第3个请求回来\")\n            }\n        }\n        \n        group.notify(queue: queueRequest){\n            print(\"请求结束\")\n        }\n        \n        print(\"其他任务\");\n    }\n```\n\n## 方法二 使用计数器的方式\n```swift\n@IBAction func requestNetAction(_ sender: Any) {\n        \n        let array = [\"https://httpbin.org/get\",\n                     \"http://test.api.wukongtv.com/setting/init\",\n                     \"http://test.api.wukongtv.com/setting/ad\"]\n        \n        sendBatchRequests(_requests: array) { \n            print(\"请求结束\")\n        }\n        \n        print(\"其他任务\");\n    }\n    \n    func sendBatchRequests(_requests:Array<String>, completionHandler: @escaping ()->()) {\n        var finshCount = 0\n        let allTaskCount = _requests.count\n        \n        let queue = DispatchQueue.global();\n        queue.async {\n            print(\"+++++\"+Thread.current.description)\n            print(\"开始发出请求\")\n            for request in _requests {\n                print(\"-----\"+Thread.current.description)\n                print(\"发出请求:\" + request.description)\n                Alamofire.request(request).responseJSON { response in\n                    print(\"*****\"+Thread.current.description)\n                    print(\"收到请求\" + (response.request?.description)! )\n                    finshCount += 1\n                    if (finshCount == allTaskCount){\n                        completionHandler()\n                    }\n                }\n            }\n        }\n    }\n```\n\n## 方法三 使用GCD group的enter、leave、notify方法\n```swift\n@IBAction func requestNetAction(_ sender: Any) {\n        \n        let group = DispatchGroup()\n        group.enter()\n        print(\"开始第1个请求\")\n        Alamofire.request(\"https://httpbin.org/get\").responseJSON { response in\n            print(\"接收第1个请求\")\n            group.leave()\n        }\n        \n        group.enter()\n        print(\"开始第2个请求\")\n        Alamofire.request(\"https://httpbin.org/get\").responseJSON { response in\n            print(\"接收第2个请求\")\n            group.leave()\n        }\n        \n        group.enter()\n        print(\"开始第3个请求\")\n        Alamofire.request(\"https://httpbin.org/get\").responseJSON { response in\n            print(\"接收第3个请求\")\n            group.leave()\n        }\n        \n        group.notify(queue: DispatchQueue.main) {\n            print(\"任务结束\")\n        }\n        \n        print(\"接着往下跑\")\n        \n    }\n```\n\n## 方法四 BlockOperation\n\n由于网络请求是异步的，导致回调并不是安装BlockOperation的依赖顺序进行执行的，所以使用这种方法还有结合上面的方式进行结果的同步。\n\n```\n@IBAction func requestNetAction(_ sender: Any) {\n        \n        let queue = OperationQueue()\n        \n        let blockOpe1 = BlockOperation()\n        blockOpe1.addExecutionBlock {\n            print(\"blockOpe1执行了\")\n        }\n        \n        let blockOpe2 = BlockOperation()\n        blockOpe2.addExecutionBlock {\n            print(\"开始第1个请求\")\n            Alamofire.request(\"https://httpbin.org/get\").responseJSON { response in\n                print(\"接收第1个请求\")\n            }\n        }\n        \n        let blockOpe3 = BlockOperation()\n        blockOpe3.addExecutionBlock {\n            print(\"开始第2个请求\")\n            Alamofire.request(\"https://httpbin.org/get\").responseJSON { response in\n                print(\"接收第2个请求\")\n            }\n        }\n        \n       \n        blockOpe1.addDependency(blockOpe2)\n        blockOpe1.addDependency(blockOpe3)\n        queue.addOperation(blockOpe1)\n        queue.addOperation(blockOpe2)\n        queue.addOperation(blockOpe3)\n\n        print(\"接着往下跑\")\n\n```\n\n\n\n# 参考\n\n[GCD－两个网络请求同步问题](http://www.jianshu.com/p/07eb268c93f2)\n[iOS中多个网络请求的同步问题总结](http://www.jianshu.com/p/943dcb9ad632)\n[使用dispatch_group来进行线程同步](http://www.jianshu.com/p/228403206664)\n[Swift 3必看：从使用场景了解GCD新API](http://www.jianshu.com/p/fc78dab5736f)\n[YTKNetwork](https://github.com/yuantiku/YTKNetwork)\n","tags":["iOS 网络"],"categories":["iOS"]},{"title":"关于iOS推送的总结","url":"/2017/05/12/关于iOS推送的总结/","content":"# 本文目的\n本文不讲证书配置，不讲APNS的原理，仅描述开发过程中遇到的坑坑洼洼。\n\n# 推送中的一些坑\n大家都知道iOS中推送有本地推送和远程推送。那么我们就分开说了，先说远程推送。\n\n## 远程推送中的一些坑\n就远程推送而言，应用推送到达的场景有：\n- App未启动\n- APP在后台\n- 用户正在玩App\n  每种情况下有不同的处理方式，再加上不同的版本iOSApi不一致，导致处理逻辑相当繁琐。\n  先介绍远程推送的一些代理方法\n\n<!--more-->\n# 推送提醒方式\n\n无论是远程推送还是本地推送，推送的提醒方式是由系统版本决定的，在设置—>悟空遥控器->通知里面可以选择推送的提醒方式。\n\n# 远程推送\n\n## 注册推送\n\n方法一：\n\n```\n//iOS3到iOS8 有效，其中type的值如下枚举\n- (void)registerForRemoteNotificationTypes:(UIRemoteNotificationType)types;\n//iOS3到iOS8 有效\ntypedef NS_OPTIONS(NSUInteger, UIRemoteNotificationType) {\n    UIRemoteNotificationTypeNone    = 0,\n    UIRemoteNotificationTypeBadge   = 1 << 0,\n    UIRemoteNotificationTypeSound   = 1 << 1,\n    UIRemoteNotificationTypeAlert   = 1 << 2,\n    UIRemoteNotificationTypeNewsstandContentAvailability = 1 << 3,\n}\n```\n\n方法二：\n\n```\n//iOS8 之后有效， 调用该方法注册推送，必须先调用registerUserNotificationSettings设置推送形式。\n- (void)registerForRemoteNotifications;\n\n//UIUserNotificationSettings, UIUserNotificationType 取下面两个枚举值\n+ (instancetype)settingsForTypes:(UIUserNotificationType)types\n                      categories:(nullable NSSet<UIUserNotificationCategory *> *)categories;\n              \n// iOS8 到 iOS10\ntypedef NS_OPTIONS(NSUInteger, UIUserNotificationType) {\n    UIUserNotificationTypeNone    = 0,      \n    UIUserNotificationTypeBadge   = 1 << 0, \n    UIUserNotificationTypeSound   = 1 << 1, \n    UIUserNotificationTypeAlert   = 1 << 2, \n}\n\niOS 10+\ntypedef NS_OPTIONS(NSUInteger, UNAuthorizationOptions) {\n    UNAuthorizationOptionBadge   = (1 << 0),\n    UNAuthorizationOptionSound   = (1 << 1),\n    UNAuthorizationOptionAlert   = (1 << 2),\n    UNAuthorizationOptionCarPlay = (1 << 3),\n}\n```\n\n方法三：\n\n```\n//UNUserNotificationCenter 的方法 iOS 10+\n- (void)requestAuthorizationWithOptions:(UNAuthorizationOptions)options \n                      completionHandler:(void (^)(BOOL granted, NSError *error))completionHandler;\n```\n\n## 接收方法\n\n```\n// 如果APP正在运行时接收到远程推送消息，系统会调用此方法。iOS3-iOS10\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo;\n\n//程序处于后台或者被杀死状态，收到远程通知后，当你进入(aunch)程序时，系统调用此方法，iOS 7 之后\n- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo fetchCompletionHandler:(void (^)(UIBackgroundFetchResult result))completionHandler;\n```\n\n*如果两个代理方法都被实现了，系统将只调用application:didReceiveRemoteNotification:fetchCompletionHandler:*\n\n另外需要注意：从didFinishLaunchingWithOptions 方法里面可以获得APP从通知栏里启动并获取携带的推送参数，这里可以不做判断，都归于didReceiveRemoteNotification:fetchCompletionHandler 中处理。并且iOS10之后废弃了UIApplicationLaunchOptionsRemoteNotificationKey。\n\n```\n// iOS 10+ 后台推送消息接收\n- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void (^)())completionHandler;\n\n// iOS 10+ 前台推送消息处理, 可在APP 前台状态下,弹出推送弹窗\n- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(nonnull UNNotification *)notification withCompletionHandler:(nonnull void (^)(UNNotificationPresentationOptions))completionHandler;\n```\n\n\n\n## 取消推送\n\niOS10之前不能取消一个已发送未点击的本地通知，但是iOS10之后可以根据identifiers取消某一个指定的通知，不管是待发送的还是已发送未点击的。\n\n```\n//ios4-ios10 取消一个指定的推送\n- (void)cancelLocalNotification:(UILocalNotification *)notification;\n//ios4-ios10 取消所有的本地推送\n- (void)cancelAllLocalNotifications ;\n\n//iOS10 + 取消待推送的消息，根据identifiers\n- (void)removePendingNotificationRequestsWithIdentifiers:(NSArray<NSString *> *)identifiers;\n- (void)removeAllPendingNotificationRequests;\n\n//iOS10 + 取消已经推送的消息，根据identifiers\n- (void)removeDeliveredNotificationsWithIdentifiers:(NSArray<NSString *> *)identifiers __TVOS_PROHIBITED;\n- (void)removeAllDeliveredNotifications __TVOS_PROHIBITED;\n```\n\n\n\n## 参考\n\nhttp://www.simpleapples.com/2014/09/ios8-register-notification-fail/\n","tags":["APNS"]},{"title":"iOS_Bonjour编程总结二","url":"/2017/05/02/iOS-Bonjour编程总结二/","content":"# 简介\n本文紧接上文[iOS_Bonjour编程总结一](http://riverli.me/2017/04/14/iOS_Bonjour%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%E4%B8%80/)，进一步描述Bonjour编程中客户端编写部分。\n<!--more-->\n\n## 1. 浏览服务\n我们可以使用NSNetServiceBrowser类来进行服务扫描，浏览服务不需要知道服务端的IP地址，端口等信息，只需要指定在某一个域名下搜索某种类型的服务。浏览服务的代码如下：\n```objective-c\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    if (browser == nil) {\n        services = [NSMutableArray new];\n        browser = [[NSNetServiceBrowser alloc] init];\n        browser.delegate = self;\n      // 设置type, 和 domain， domain 一般为空，表示当前局域网环境。\n        [browser searchForServicesOfType:@\"_associateHelp._tcp.\" inDomain:@\"\"];\n    }\n}\n```\n\n我们可以通过NSNetServiceBrowser的代理方法监听浏览服务过程中每个关键节点的的信息。如下：\n\n```objective-c\n#pragma mark - NSNetServiceBrowserDelegate\n//即将开始扫描\n- (void)netServiceBrowserWillSearch:(NSNetServiceBrowser *)browser {\n    NSLog(@\"netServiceBrowserWillSearch\");\n}\n//停止扫描\n- (void)netServiceBrowserDidStopSearch:(NSNetServiceBrowser *)browser{\n    NSLog(@\"netServiceBrowserDidStopSearch\");\n}\n//发现服务，moreComing 用来判断还有没有服务过来。\n- (void)netServiceBrowser:(NSNetServiceBrowser *)browser didFindService:(NSNetService *)service moreComing:(BOOL)moreComing {\n    NSLog(@\"%@\", service.name);\n    NSLog(@\"%@\", service.type);\n    NSLog(@\"%ld\", service.port);\n    NSLog(@\"didFindService\");\n    //测试代码，这里只有一个服务，我就直接做解析了。\n    [self connectToService:service];\n}\n//服务被移除\n- (void)netServiceBrowser:(NSNetServiceBrowser *)browser didRemoveService:(NSNetService *)service moreComing:(BOOL)moreComing {\n    NSLog(@\"%@\", service.name);\n    NSLog(@\"%@\", service.type);\n    NSLog(@\"didRemoveService\");\n}\n- (void)netServiceBrowser:(NSNetServiceBrowser *)browser didNotSearch:(NSDictionary<NSString *, NSNumber *> *)errorDict {\n    NSLog(@\"didNotSearch\");\n}\n//下面两个方法是关于domain域变化的监听。\n- (void)netServiceBrowser:(NSNetServiceBrowser *)browser didFindDomain:(NSString *)domainString moreComing:(BOOL)moreComing {\n    NSLog(@\"didFindDomain\");\n}\n- (void)netServiceBrowser:(NSNetServiceBrowser *)browser didRemoveDomain:(NSString *)domainString moreComing:(BOOL)moreComing {\n    NSLog(@\"didRemoveDomain\");\n}\n```\n\n## 2. 解析服务\n\n我在搜索到服务的时候就调用了\n\n```objective-c\n[self connectToService:service];\n-(void)connectToService:(NSNetService *)service {\n    service.delegate = self;\n    //解析服务\n    [service resolveWithTimeout:5];\n}\n```\n\n这个方法主要的作用是：在指定的时间内解析服务，解析成功调用NSNetServiceDelegate的netServiceDidResolveAddress， 解析失败调用didNotResolve。\n\n```objective-c\n#pragma NSNetServiceDelegate\n-(void)netServiceDidResolveAddress:(NSNetService *)sender\n{\n    NSInputStream *iStream;\n    NSOutputStream *oStream;\n    BOOL error = NO;\n    if (![sender getInputStream:&iStream outputStream:&oStream]) {\n        error = YES;\n    }\n    //inputstream\n    if (iStream != NULL) {\n        inputStream = iStream;\n        inputStream.delegate = self;\n        [inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n        if (inputStream.streamStatus == NSStreamStatusNotOpen) {\n            [inputStream open];\n        }\n    }else{\n        error = YES;\n    }   \n}\n- (void)netService:(NSNetService *)sender didNotResolve:(NSDictionary<NSString *,NSNumber *> *)errorDict\n{}\n```\n\n## 3. 交互\n\n在解析服务成功之后，我们就可以拿到服务端的input/output Stream了，之后就可以随意使用流操作进行读写操作。关于socket的使用，可以参考[iOS_NSStream使用指南](http://riverli.me/2017/04/25/iOS-NSStream%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/)\n\n\n\n# 参考资料\n\n[参考一:c语言中文网 ](http://c.biancheng.net/cpp/html/374.html)\n\n[参考二：slvher的博客](http://blog.csdn.net/slvher/article/details/8856003)\n\n[参考三：Apple : Stream Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Streams/Streams.html#//apple_ref/doc/uid/10000188-SW1)\n\n参考四：iOS网络高级编程\n","tags":["网络编程"],"categories":["iOS"]},{"title":"iOS_NSStream使用指南","url":"/2017/04/25/iOS-NSStream使用指南/","content":"# NSStream简介\nstream(流)是编程中的一个基本抽象概念：一系列的位有序的从一个点传输到另一个点。Cocoa提供了三个类代表steam以便于你在程序中使用：NSStream，NSInputStream，NSOutputStream。使用这些类的实例，你可以读或者写数据从文件或者应用程序的内存。你也可使用在基于socket连接的网络中使用这些对象和远程主机交换数据。你也可继承stream类而获取专有的stream操作。常见的Stream应用场景有：读/写取文件，socket通信, 从NSData中读/写数据, 写数据到buffer中。\n<!--more-->\n# NSInputStream\nNSInputStream 是输入流，对客户端而言，就是读数据。\n## 读文件\n``` objective-c\n@interface ViewController ()<NSStreamDelegate>\n@property (nonatomic,strong)NSInputStream *istream;\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n \t\n \t//获取所读文件的路径   \n    NSString *path = [[NSBundle mainBundle] pathForResource:@\"init\" ofType:@\"json\"];\n    [self setUpStreamForFile:path];\n}\n\n-(void)setUpStreamForFile:(NSString *)path\n{\n\t//创建NSInputStream\n    self.istream = [[NSInputStream alloc] initWithFileAtPath:path];\n    // 设置delegate\n    self.istream.delegate = self;\n    // 加入到Runloop中\n    [self.istream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    // 打开流\n    [self.istream open];\n}\n\n- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;\n{\n    switch (eventCode) {\n    \t// 有数据可读\n        case NSStreamEventHasBytesAvailable:\n        {\n        \t//读取数据并打印\n            NSMutableData *data = [[NSMutableData alloc] init];\n            uint8_t buf[2048];\n            NSInteger len = 0;\n            len = [(NSInputStream *)aStream read:buf maxLength:2048];\n            if (len) {\n                [data appendBytes:(const void *)buf length:len];\n                NSString *str = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n                NSLog(@\"%@\", str);\n            }else{\n                NSLog(@\"no buffer\");\n            }\n            break;\n        }\n        //读到了流的结尾\n        case NSStreamEventEndEncountered:{\n        \t// 关闭流\n            [aStream close];\n            [aStream removeFromRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n            aStream = nil;\n            break;\n        }\n            \n        default:\n            break;\n    }\n}\n```\n\n# NSOutputStream\nNSOutputStream是输入流，对于客户端而言，就是写数据。\n\n```objective-c\n\n#import \"ViewController.h\"\n\n@interface ViewController ()<NSStreamDelegate>\n{\n    NSString *pathtxt;\n}\n@property (nonatomic,strong)NSOutputStream *ostream;\n@property (nonatomic,strong)NSData *data;\n@property (nonatomic,assign)NSInteger readBytes;\n@property (nonatomic,assign)NSInteger byteIndex;\n\n@end\n\n@implementation ViewController\n\n- (void)viewDidLoad {\n    [super viewDidLoad];\n    \n    NSString *path = [[NSBundle mainBundle] pathForResource:@\"init\" ofType:@\"json\"];\n    self.data = [NSData dataWithContentsOfFile:path];\n    pathtxt =  NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;\n    //建议这个路径一定要是沙盒中的路径，放在工程目录里面是无法写入数据的。\n    pathtxt =  [pathtxt stringByAppendingPathComponent:@\"cache.json\"];\n    [self createOutputStream];\n}\n\n\n-(void)createOutputStream\n{\n    self.ostream = [[NSOutputStream alloc] initToFileAtPath:pathtxt append:YES];\n    self.ostream.delegate = self;\n    [self.ostream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n    [self.ostream open];\n}\n\n\n\n- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)eventCode;\n{\n    switch (eventCode) {\n        case NSStreamEventHasSpaceAvailable:\n        {\n            self.readBytes += self.byteIndex;\n            NSUInteger data_len = [_data length];\n            NSUInteger len = (data_len - self.readBytes >= 1024) ? 1024 : (data_len - self.readBytes);\n            uint8_t buf[len];\n            [self.data getBytes:buf range:NSMakeRange(self.readBytes, len)];\n            len = [(NSOutputStream *)aStream write:buf maxLength:sizeof(buf)];\n            self.byteIndex = len;\n            break;\n        }\n        case NSStreamEventEndEncountered:\n        {\n            [aStream close];\n            [aStream removeFromRunLoop:[NSRunLoop currentRunLoop]\n                              forMode:NSDefaultRunLoopMode];\n            aStream = nil; // oStream is instance variable\n            break;\n        }\n\n        default:\n            break;\n    }\n}\n\n\n@end\n```\n\n# RunLoop的作用\n我们都知道RunLoop可以保留线程不释放，有任务的时候执行，没有任务的时候休息并且不阻塞UI线程。我们在对流进行读／写操作时候，如果没有runloop我们需要一次性将流中的数据读完或者写完，这显然是不现实的，那么我们可以通过另一种方式进行分段读取。\n```objective-c\nwhile (1) {\n    if (len == 0) break;\n    \n    if ([oStream hasSpaceAvailable])\n    {\n        (void)strncpy(buf, readBytes, len);\n        readBytes += len;\n        if ([oStream write:(const uint8_t *)buf maxLength:len] == -1)\n        {\n            [self handleError:[oStream streamError]];\n            break;\n        }\n        [bytesWritten setIntValue:[bytesWritten intValue]+len];\n        len = (([data length] - [bytesWritten intValue] >= 1024) ? 1024 : [data length] - [bytesWritten intValue]);\n    }\n}\n```\n使用while循环，每次读取一定的字节并记录读取的位置，知道读取完毕，结束white循环。这么做也能达到我们的目的，但是显然这会造成阻塞线程。所以最好的方法还是使用runloop监听数据源是否可读/写。\n\n# 参考\n[Stream Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Streams/Streams.html)\n[南峰子的博客](http://southpeak.github.io/2014/07/17/ioszhong-liu-stream-de-shi-yong/)\n","tags":["NSStream"]},{"title":"iOS_Bonjour编程总结一","url":"/2017/04/14/iOS_Bonjour编程总结一/","content":"# Bonjour 简介\nBonjour是这样的一种技术，设备可以通过它轻松探测并连接到相同网络中的其他设备，整个过程只需要很少的用户参与或是根本就不需要用户参与。典型的Bonjour应用有Remote应用，AirPrint等。建立一个Bonjour连接一般需要三个步骤，服务端发布服务，客户端浏览服务，客户端服务端交互。\n<!--more-->\n# 发布服务\n\n## 1.   创建socket\n\ndemo代码：\n\n```objective-c\n-(BOOL)setupListeningSocket\n{\n    CFSocketContext socketCtxt = {0,(__bridge void*)self, NULL, NULL, NULL};\n    \n    ipv4socket = CFSocketCreate(kCFAllocatorDefault, \n                                PF_INET, \n                                SOCK_STREAM, \n                                IPPROTO_TCP, \n                                kCFSocketAcceptCallBack, \n                                (CFSocketCallBack)&BonjourServerAcceptCallBack, \n                                &socketCtxt);\n    \n    if (ipv4socket == NULL) {\n        if (ipv4socket) {\n            CFRelease(ipv4socket);\n        }\n        ipv4socket = NULL;\n        return NO;\n    }\n    \n    int yes = 1;\n    setsockopt(CFSocketGetNative(ipv4socket),\n               SOL_SOCKET,\n               SO_REUSEADDR,\n               (void *)&yes,\n               sizeof(yes));\n    \n    struct sockaddr_in addr4;\n    memset(&addr4, 0, sizeof(addr4));\n    addr4.sin_len = sizeof(addr4);\n    addr4.sin_family = AF_INET;\n    addr4.sin_port = htons(port);\n    addr4.sin_addr.s_addr = htonl(INADDR_ANY);\n    NSData *address4 = [NSData dataWithBytes:&addr4 length:sizeof(addr4)];\n    \n    if (kCFSocketSuccess != CFSocketSetAddress(ipv4socket, (__bridge CFDataRef)address4)) {\n        NSLog(@\"Error setting ipv4 socket address\");\n        if (ipv4socket) {\n            CFRelease(ipv4socket);\n        }\n        ipv4socket = NULL;\n        return NO;\n    }\n    \n    if (port == 0) {\n        NSData *addr = (__bridge NSData*)CFSocketCopyAddress(ipv4socket);\n        memcpy(&addr4, [addr bytes], [addr length]);\n        port = ntohs(addr4.sin_port);\n    }\n    \n    CFRunLoopRef cfr1 = CFRunLoopGetCurrent();\n    CFRunLoopSourceRef src4 = CFSocketCreateRunLoopSource(kCFAllocatorDefault, ipv4socket, 0);\n    CFRunLoopAddSource(cfr1, src4, kCFRunLoopCommonModes);\n    CFRelease(src4);\n    \n    return YES;\n}\n```\n\n### 代码解析\n\n**CFSocketContext**\n\n是一个结构体，包含了自定义数据和回调函数，可以在其中操作CFSocket对象的具体行为。\n\n```c\ntypedef struct {\n    CFIndex\tversion;\n    void *\tinfo;\n    const void *(*retain)(const void *info);\n    void\t(*release)(const void *info);\n    CFStringRef\t(*copyDescription)(const void *info);\n} CFSocketContext;\n```\n\n*version*： 必须是0， 结构体版本号。\n\n*info*: 指向自定义数据的指针，它会在CFSocket创建的时候与之关联，这个指针会被传递给所有定义在context内的回调方法。\n\n*retain*: 一个定义在info指针上的retain 回调。可以是NULL。\n\n*release*： 一个定义在info指针上的relsease回调。可以是NULL。\n\n*copyDescription*: 一个定义在info指针上的拷贝描述回调。可以是NULL。\n\n**CFSocketCreate**\n\n```c\nCFSocketCreate(CFAllocatorRef allocator, \n               SInt32 protocolFamily, \n               SInt32 socketType, \n               SInt32 protocol, \n               CFOptionFlags callBackTypes, \n               CFSocketCallBack callout, \n               const CFSocketContext *context);\n```\n\n创建一个指定协议和类型的CFSocket对象。\n\n*allocater*： 分配器是用来为新对象分配内存的，传递NULL或者KCFAllocatorDefault 使用当前默认的分配器。\n\n*protocolFamily*: socket的协议族，如果为负数或者0，则socket默认为PE_INET。\n\n*socketType*:  所创建的Socket的类型，如果protocolFamily是PE_INET并且socketType是负数或者0，socketType的默认值是SOCK_STREAM。\n\n*protocol*： socket的协议。如果protocolFamily是PE_INET并且protocol是负数或者0，那么socket的protocol的默认值是IPPROTO_TCP。如果socketType是SOCK_STREAM或者SOCK_DGRAM那么默认为IPPROTO_UDP。\n\n*callBackTypes*:  一个按位或结合的socket类型，会调起socket的*callout*.\n\n```c\ntypedef enum CFSocketCallBackType : CFOptionFlags {\n    kCFSocketNoCallBack = 0,\n    kCFSocketReadCallBack = 1,\n    kCFSocketAcceptCallBack = 2,\n    kCFSocketDataCallBack = 3,\n    kCFSocketConnectCallBack = 4,\n    kCFSocketWriteCallBack = 8\n} CFSocketCallBackType;\n```\n\n*callout*:  当一种callBackTypes被激活时这个方法被调用。\n\n*context*：一个保存着CFSocket对象上下文信息的结构体。函数将信息拷贝出结构体之外，所以上下文指向的内存不需要超出函数的调用，可以是NULL。\n\n**setsockopt**`^参考1^`\n\n```c\nint setsockopt(int s, \n               int level, \n               int optname, \n               const void * optval,\n               socklen_toptlen);\n```\n\n用来设置参数 *s* 所指定的socket状态。参数 *level* 代表代表预设置的网络层。一般设置为SOL_SOCKET 以存取socket层。参数 *optname* 代表欲设置的选项：\n\n​\tSO_DEBUG 打开或者关闭排错模式。\n\n​\tSO_REUSEADDR 允许在bind ()过程中本地地址可重复使用\n\n​\tSO_TYPE 返回socket 形态.\n\n​\tSO_ERROR  返回socket 已发生的错误原因\n\n​\tSO_DONTROUTE 送出的数据包不要利用路由设备来传输.\n\n​\tSO_BROADCAST 使用广播方式传送\n\n​\tSO_SNDBUF 设置送出的暂存区大小\n\n​\tSO_RCVBUF  设置接收的暂存区大小\n\n​\tSO_KEEPALIVE 期确定连线是否已终止.\n\n​\tSO_OOBINLINE 当接收到OOB 数据时会马上送至标准输入设备\n\n​\tSO_LINGER：确保数据安全且可靠的传送出去.\n\n参数 *optval* 代表欲设置的值, 参数*optlen* 则为optval 的长度.\n\n返回值：成功则返回0, 若有错误则返回-1, 错误原因存于errno.\n\n**CFSocketGetNative**\n\n返回系统原生socket， 如果返回值为-1，表示无效的socket\n\n**sockaddr_in6**\n\n```c\nstruct sockaddr_in {\n\t__uint8_t\tsin_len;\n\tsa_family_t\tsin_family;\n\tin_port_t\tsin_port;\n\tstruct\tin_addr sin_addr;\n\tchar\t\tsin_zero[8];\n};\n```\n\n*sin_family*: 指协议族，在socket编程中只能是AF_INET。\n\n*sin_port*: 存储端口号，使用网络字节顺序。\n\n*size_zero*: 是为了让sockaddr与sockadrr_in 两个数据结构保持大小相同而保留的空字节。\n\n*sin_addr*:  网络地址。\n\n*sin_len*: 根据《UNIX Network Programming Volume 1》3.1节中的说法，我们可以不关注这个细节（即可以认为这个sin_len字段存在与否对我们的应用程序是透明的）。这个字段不是每种Linux版本都提供，且POSIX标准中对struct sockaddr_in的定义是否需包含该字段不做要求。\n\n## 2. 发布Bonjour服务 \n\n```objective-c\n-(void)publicBonjour {\n    service = [[NSNetService alloc] \n               initWithDomain:@\"\" \n               type:@\"_riverli._tcp.\" \n               name:@\"riverliBonjour\" \n               port:port];\n    if (service == nil) {\n        NSLog(@\"NSNetService create failed!\");\n        return ;\n    }\n    service.delegate = self;\n    [service publish];\n}\n\n#pragma mark  NSNetServiceDelegate\n- (void)netServiceWillPublish:(NSNetService *)sender {\n    NSLog(@\"netServiceWillPublish\");\n}\n\n- (void)netServiceDidPublish:(NSNetService *)sender {\n    NSLog(@\"netServiceDidPublish\");\n}\n\n- (void)netService:(NSNetService *)sender didNotPublish:(NSDictionary<NSString *, NSNumber *> *)errorDict {\n    NSLog(@\"didNotPublish\");\n}\n\n- (void)netServiceDidStop:(NSNetService *)sender {\n    port = 0;\n    CFRelease(ipv4socket);\n    NSLog(@\"netServiceDidStop\");\n}\n```\n\n## 3. 接受socket 回调\n\n这部分可能为三个步骤：\n\n1. 在第一步创建的CFSocketCallBack对象中有接收到socket消息的回调函数BonjourServerAcceptCallBack，我们在这个回调函数中拿到当前的Bonjour服务。\n2. 如果调用类型是kCFSocketAcceptCallBack，表示接受到了一个新的连接，在这里我们创建NSStream的读写对象。\n3. 在NSStream的读写对象里，我们接受客户的信息，并将信息发送给客户端。(关于NSStream的介绍可以参考[这里](http://riverli.me/2017/04/25/iOS-NSStream%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/))\n\n```objective-c\nstatic void BonjourServerAcceptCallBack (CFSocketRef socket, \n                                         CFSocketCallBackType type, \n                                         CFDataRef address, \n                                         const void *data, \n                                         void *info) {\n    \n    Bonjour *server = (__bridge Bonjour*)info;\n    if (type == kCFSocketAcceptCallBack) { \n        // AcceptCallBack: data is pointer to a CFSocketNativeHandle\n        CFSocketNativeHandle socketHandle \n            = *(CFSocketNativeHandle *)data;\n\n        CFReadStreamRef readStream = NULL;\n        CFWriteStreamRef writeStream = NULL;\n        CFStreamCreatePairWithSocket(kCFAllocatorDefault, \n                                     socketHandle, \n                                     &readStream, \n                                     &writeStream);\n        \n        if (readStream && writeStream) {\n            CFReadStreamSetProperty\n                (readStream, \n                 kCFStreamPropertyShouldCloseNativeSocket, \n                 kCFBooleanTrue);\n            \n            CFWriteStreamSetProperty\n                (writeStream, \n                 kCFStreamPropertyShouldCloseNativeSocket, \n                 kCFBooleanTrue);\n            \n            NSInputStream *is = (__bridge NSInputStream*)readStream;\n            NSOutputStream *os = (__bridge NSOutputStream*)writeStream;\n            [server handleNewConnectionWithInputStream:is\n                                          outputStream:os];\n        } else {\n            // encountered failure\n            // no need for socket anymore\n            close(socketHandle);\n        }\n        // clean up\n        if (readStream) {\n            CFRelease(readStream);\n        }\n        if (writeStream) {\n            CFRelease(writeStream);\n        }\n    }\n}\n\n- (void)handleNewConnectionWithInputStream:(NSInputStream*)istr \n                              outputStream:(NSOutputStream*)ostr {\n    inputStream = istr;\n    outputStream = ostr;\n    \n    inputStream.delegate = self;\n    outputStream.delegate = self;\n    \n    [inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] \n                           forMode:NSDefaultRunLoopMode];\n    // output stream is scheduled in the runloop when it is needed\n\n    \n    if (inputStream.streamStatus == NSStreamStatusNotOpen) {\n        [inputStream open];\n    }\n    \n    if (outputStream.streamStatus == NSStreamStatusNotOpen) {\n        [outputStream open];\n    }\n}\n\n#pragma mark - NSStreamDelegate\n- (void)stream:(NSStream *)aStream \n   handleEvent:(NSStreamEvent)eventCode {\n    \n    switch (eventCode) {\n        case NSStreamEventHasBytesAvailable:\n            if (aStream == inputStream) {\n                //接收数据\n            }\n            break;\n        \n        case NSStreamEventHasSpaceAvailable: {\n            if (aStream == outputStream) {\n               //发送数据\n            }\n            break;\n        }\n        case NSStreamEventOpenCompleted:\n            if (aStream == inputStream) {\n                NSLog(@\"Input Stream Opened\");\n            } else {\n                NSLog(@\"Output Stream Opened\");\n            }\n            break;\n            \n        case NSStreamEventEndEncountered: {\n            [aStream close];\n            [aStream removeFromRunLoop:[NSRunLoop currentRunLoop] \n                               forMode:NSDefaultRunLoopMode];\n            break;\n        }\n        \n        case NSStreamEventErrorOccurred:\n            if (aStream == inputStream) {\n                NSLog(@\"Input error: %@\", [aStream streamError]);\n            } else {\n                NSLog(@\"Output error: %@\", [aStream streamError]);\n            }\n            break;\n            \n        default:\n            if (aStream == inputStream) {\n                NSLog(@\"Input default error: %@\", [aStream streamError]);\n            } else {\n                NSLog(@\"Output default error: %@\", [aStream streamError]);\n            }\n            break;\n    }\n}\n```\n\n\n\n# 参考资料\n\n[参考一:c语言中文网 ](http://c.biancheng.net/cpp/html/374.html)\n\n[参考二：slvher的博客](http://blog.csdn.net/slvher/article/details/8856003)\n\n[参考三：Apple : Stream Programming Guide](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Streams/Streams.html#//apple_ref/doc/uid/10000188-SW1)\n\n参考四：iOS网络高级编程\n\n\n\n\n\n\n\n","tags":["网络编程"],"categories":["iOS"]},{"title":"dispatch_async的block中是否该使用_weak self","url":"/2017/02/19/dispatch_async的block中是否该使用_weak self/","content":"\n# 问题分析\n\n我看过很多文章关于在dispatch_async的block里面使用_weak self, 但是让我疑惑的是，以下代码是否需要必须使用_weak self, 因为我也看到了很多观点说，在有些情况下不需要使用__weak self.\n```objective-c\nself.myQueue = dispatch_queue_create(\"com.biview.core_data\", NULL);\n\ndispatch_async(self.myQueue, ^(void){\n\tif(!self.var1){\n\t\tself.var1 = \n\t}\n\n\tdispatch_async(dispatch_get_main_queue(), ^(void){\n\t\tif([self.var2 superview]) {\n\t\t\t[self.var2 removeFromSuperview];\n\t\t}\n\n\t\t[self.Label setText:text];\n\t});\n});\n```\n<!--more-->\n\n# 解析\n针对上面的问题，我们假设：self是指向UIViewController的对象指针。\n**考虑以下几点：**\n- UIViewController是\"UIkit\"对象，UIKit对象不应该在非主线程发送消息，也就是说，这些方法只能在主线程中执行。\n- 当一个block被添加进一个同步或者异步队列，这个block最终都会被执行，除非在执行到它之前应用程序被杀死。\n- 当block被拷贝的时候，strong类型的指针会被retained, 当block执行完毕之后被销毁的时候才会执行released操作。\n- weak类型的指针不会被retained和released。\n\n在上面的例子中，self是在主线程的队列中，不必担心有任何bug产生。\n\n## 究竟发生了什么？\n当在dispatch的异步队列的block中捕获到self时，self会被执行retained操作，当block执行完毕后self执行released操作。\n这意味着：当block执行完毕后，self的生命周期才会结束。上例中的第二个block是在主线程的队列中，它保证了self一直存活着当这个block被执行的时候。\n在程序中存在潜在危险的操作是：延长 self 的生命周期。\n\n如果你明确的不希望延长UIViewController对象的生命周期，而是当block被执行的时候去检查UIViewController对象到底是否存在，你可以使用 _weak self. 需要注意的是block最后都会被执行，不管UIViewController是否存活还是已经被释放了。\n\n如果你希望如果UIViewController已经被释放了，那么block不做任何事情，可以写成 _weak self.\n\n```objective-c\nMyController * _weak weakSelf = self;\ndispatch_async(queue, ^{\n\tMyController *strongSelf = weakSelf;\n\tif(strongSelf){\n\t\t...\n\t}else {\n\t\t// self has been deallocted in the meantime.\n\t}\n});\n```\n**不能在非主线程中向UIKit对象发送消息。**\n另一个细微的错误可能发生在UIKit对象执行方法在非主线程。\n\n如果block在异步线程中捕获了一个UIKit对象，可能发生的是：block 是最后一个持有改UIKit的强引用。当block执行完的时候，UIKit对象将被release，因为是UIKit对象的最后一个强引用，所有该UIKit对象将被释放，但是，释放操作发生在block所执行的线程-它不是主线程，所有，风险即将发生，UIKit对象的dealloc方法将被调用(UI 对象应该在主线程中被回收，因为在它们的 dealloc 方法被调用回收的时候，可能会去改变 view 的结构关系，而如我们所知，这种操作应该放在主线程来进行，见参考二)。\n\n避免这个错误：\n```objective-c\nUIViewController *strongUIKitPointer = ...\ndispatch_async(non_main_queue), ^{\n\t...//do someting\n\tdispatch(dispatch_get_main_queue(),^{\n\t\t[strongUIkitPointer self]; //self is a method, too -doing nothing.\n\t});\n});\n```\n\n# 举例\n双向强引用发生在：一个强类型对象A持有一个强类型对象B，并且对象B强引用对象A。“Block”是一个强引用对象。\n\n人为的双向强引用举例：\n```objective-c\ntypedef void(^my_completion_block_t)(NSArray* result);\n\n@interface UserViewController : UIViewController\n@property (nonatomic, copy) my_completion_block_t completion;\n@property (nonatomic) NSArray *users;\n```\n\non \"UserViewController.m\"\n```objective-c\nself.completion = ^(NSArray *users){\nself.users = users;\n}\n[self fetchUsers]; \n```\n这是一个典型了强引用循环。UserViewController 有一个Block类型的属性，所有UserViewController对象强引用着block。而block捕获到self的时候执行强引用操作，所有形成了强引用循环。\n\n解决方式：\n1. 使用_weak 指针指向self.\n```objective-c\nUserViewController * _weak weakSelf = self;\n\nself.completion = ^(NSArray *user){\n\tUsersViewController *strongSelf = weakSelf;\n\tif(strongSelf){\n\t\tstrongSelf.users = users;\n\t}else{\n\t\t// the view controller does not exist anymore.\n\t}\n};\n```\n\n2. 使用__block 指针执行self, 执行完毕后将__block 指针指向nil.\n```objective-c\nUsersViewController *__block blockSelf = self;\nself.completion=^(NSArayy *users){\n\tself.completion = ^(NSArray *users){\n\t\tblockSelf.users = users;\n\t\tblockSelf = nil;\n\t}\n}\n```\n\n--完--\n\n# 参考\n1. [stack overflow](http://stackoverflow.com/questions/21987067/using-weak-self-in-dispatch-async-function#comment33353782_21988407)\n2. [objc-cn](https://objccn.io/issue-2-4/)\n","tags":["block, weak, dispatch_async"],"categories":["iOS"]},{"title":"hexo搭建博客简单记录","url":"/2017/01/23/hexo搭建博客简单记录/","content":"\n## 环境介绍\ngit\n[node.js](https://nodejs.org/en/)\n[hexo](https://hexo.io/zh-cn/)\n[CodingNet](https://coding.net/)\n<!--more-->\n## 步骤\n1. 安装git\n2. 安装node.js\n3. 在coding.net注册账号并创建一个项目,项目名随意.\n4. 安装hexo\n5. hexo init 博客目录\n\n## 配置\n目的: 将本地博客目录的**public**文件夹push到仓库里.\n1. 将建好的仓库clone 下来, 配置上传脚本.\n``` objective-c\n#!/bin/bash\necho '**********生成文件内容**********'\ncd /Users/river/MyJob/riverliBlog/\nhexo g\necho '**********拷贝public中的内容**********'\ncp -r /Users/river/MyJob/riverliBlog/public/ /Users/river/Dev/riverliBlog\ncd /Users/river/Dev/riverliBlog/\ngit add *\ngit commit -m \"hexo 发布\"\necho '**********commit成功**********'\ngit push\necho '**********push成功**********'\n```\n\n2. 新建文章, 并用sublime Text 打开\n``` objective-c\n#!/bin/bash\necho '请输入文章名字:'\nread name\ncd /Users/river/MyJob/riverliBlog\nhexo new $name\nshopt -s expand_aliases\nsource ~/.bash_profile\nsubl /Users/river/MyJob/riverliBlog/source/_posts/${name}.md\n```\n","tags":["hexo"],"categories":["博客"]},{"title":"ios-webview-dispatch_async主线程调用alert卡死","url":"/2017/01/22/ios-webview-dispatch-async主线程调用alert卡死/","content":"\n\n# 问题描述\niOS里做webview调用js方法的时候遇到一个问题, 调用的js方法里面有一句alert(), 结果导致界面卡死, 无法点击. 代码类似如下:\n``` objective-c  \ndispatch_async(dispatch_get_main_queue(), ^{\n\t[self.webpageView stringByEvaluatingJavaScriptFromString:@\"alert(1)\"];\n});\n```\n<!--more-->\n如何直接调用:\n```objective-c\n[self.webpageView stringByEvaluatingJavaScriptFromString:@\"alert(1)\"];\n```\n\n不会卡死, 但我们的需求是这段代码必须放在主线程.\n\n最后解决办法是这样:\n``` objective-c  \n [self.webpageView performSelectorOnMainThread:@selector(stringByEvaluatingJavaScriptFromString:) withObject:@\"alert(1)\" waitUntilDone:NO];\n\n```\n那么, 为什么造成卡死呢?\n\n# 我的分析\n先看dispatch_async的实现中,任务执行代码:\n![GCD代码片段](http://ww1.sinaimg.cn/large/d3681d85ly1fbzdg7x3mnj20sc0prjx0.jpg)\n**dispatch_atomic_inc**和**dispatch_atomic_dec**是原子操作函数.\n\n由代码可知, 在dispatch_async执行任务的时候会对当前工作的线程加原子操作.\n**什么是原子操作**\n原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切[1]  换到另一个线程),也就是说, 任务不执行完, 工作线程是不会被中断的.\n\n在我们的代码中对主线程进行了原子操作, 这时任务执行不完,主线程不会被中断.\n\n在JS中,我们知道在js中alert具有中断代码的作用, alert下面的代码在alert点击OK之前是不会被执行到的.\n\n然而,在iOS里面, 所有的UI操作都是在主线程中进行的, alert也不例外(至少点击alert的OK操作是需要主线程的), 这时alert需要主线程去进行UI操作,但是主线程被dispatch_async加了原子操作, 所有alert拿不到主线程的操作权, 但是dispatch_async又要等到任务执行完才能释放主线程, 所以造成了死循环.(dispatch_async拿着主线程不释放,等着js执行完才能释放, alert需要主线程才能执行操作,alert下面的代码无法执行到.)\n\n**分析解决办法**\n```objective-c\n [self.webpageView performSelectorOnMainThread:@selector(stringByEvaluatingJavaScriptFromString:) withObject:@\"alert(1)\" waitUntilDone:NO];\n```\n 官方注释wait才是的意思是:\n **A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. Specify YES to block this thread; otherwise, specify NO to have this method return immediately.**\n 大致意思是:\n 如果wait是yes,会锁死主线程,直到selector方法执行完. 如果为no,selector方法会立即返回.\n\n **SO**\n 造成这个问题的原因是:竞争主线程,造成界面卡死.\n\n # 参考资料\n [GCD 源码](https://opensource.apple.com/tarballs/libdispatch/)\n [dispatch_async 的分析](http://www.jianshu.com/p/f70cfef54052)\n","tags":["webView卡死"],"categories":["iOS"]},{"title":"WiFi直连iOS端总结","url":"/2016/12/29/WiFi直连iOS客户端实现总结/","content":"\n\n# WiFi直连iOS端总结\n## 整体流程\n功能概述：客户端通过引导用户输入家庭WiFi名称以及密码，将WiFi信息发送给TV端，TV端去连接家庭WiFi获取网上冲浪功能。\n<!--more-->\n![整体流程](http://upload-images.jianshu.io/upload_images/691666-126e8f8424f2fb4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 引导用户输入WiFi密码程序逻辑\n在这个界面，主要是监听WiFi的变化，自动获取WiFi的SSID，并填充在WiFi名称输入框。\n点击下一步是，如果连接的WiFi是TV端的WiFi，则不能进行下一步。通过SSID前缀判断。\n### 添加WiFi状态监听\n每次WiFi状态发生变化，都发出一个通知名为 \"WK_NOTIFICATION_WIFI_CHANGED_IN_WIFICONNECT\"的消息，我们在该页面通过监听这个通知，实时获取WiFi消息，并填充WiFi名。\nWiFiMessage 中包含了监听WiFi的代码。\n``` objectivec\n+ (void)startMonitorWifiChange {\nCFNotificationCenterAddObserver(\nCFNotificationCenterGetDarwinNotifyCenter(), \nNULL, \n&onNotifyCallback, \nCFSTR(kNotifySCNetworkChange),  \nNULL, \nCFNotificationSuspensionBehaviorDeliverImmediately);\n}\n\n+ (void)stopMonitorWifiChange {\nCFNotificationCenterRemoveObserver(\nCFNotificationCenterGetDarwinNotifyCenter(),\nNULL,\nCFSTR(kNotifySCNetworkChange),\nNULL);\n}\n\nstatic void onNotifyCallback(\nCFNotificationCenterRef center,\nvoid *observer,\nCFStringRef name,\nconst void *object,\nCFDictionaryRef userInfo) {\nif (CFStringCompare(name, CFSTR(kNotifySCNetworkChange), kCFCompareCaseInsensitive) == kCFCompareEqualTo) \n{\nWiFiMessage *message = [WiFiMessage sharedMessage];\n[message getCurrentWifiMessage];\n[[NSNotificationCenter defaultCenter]       postNotificationName:@\"WK_NOTIFICATION_WIFI_CHANGED_IN_WIFICONNECT\" object:nil];\n}\n}\n```\n## 提示用户切换到TV端热点程序逻辑\n在这个步骤里主要是让获取切换到TV端热点，并连接到获取到TV到IP地址，以便下一步发送WiFi名称以及密码。\n![程序逻辑](http://upload-images.jianshu.io/upload_images/691666-47e6301e80c2a5ec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 发送消息给TV端\n该页面主要是一个发送WiFi信息给TV端的过程。值得注意的是：我们这个只能判断WiFi信息是否发送成功，并不能判断TV端是否已经使用该WiFi信息连接上了外网。\n","tags":["WiFi"],"categories":["工作总结"]},{"title":"iOS现有项目手动集成ReactNative","url":"/2016/10/14/iOS现有项目手动集成ReactNative/","content":"\n\n# 介绍\n\n### 本文目的\n\n在现有iOS项目中集成ReactNative。\n<!--more-->\n### 软件环境\n\nMac OSX 10.11.6\nXcode 8\n\n### 集成方式\n\n官网推荐使用CocoaPod进行集成，但在实践的过程中，遇到一些问题，实在没有思路，故弃之。如有同学使用CocoaPod集成成功，还有留言告知，一起探讨。[官方集成文档](https://facebook.github.io/react-native/docs/integration-with-existing-apps.html)\n\n# 集成步骤\n\n#### 1. 首先我们创建一个iOS项目作为已有项目。(我创建的项目名是：ReactTest)\n\n#### 2. 创建一个ReactNative项目，目的是获取最新的React Native包。(项目名是：test)\n```objective-c\nreact-native init test\n```\n#### 3. 将test/node_modules拷贝到ReactTest根目录下\n#### 4. 在ReactTest项目中创建Group：Libraries\n <p style=\"text-align: center\"><img src=\"http://upload-images.jianshu.io/upload_images/691666-0d9e46fc66d57a0e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"/></p>\n#### 5. 在Group：Libraries中添加依赖的React Native项目。(不同的项目所添加的依赖库不同，需要开发者自己甄别)\n<p style=\"text-align: center\"><img src=\"http://upload-images.jianshu.io/upload_images/691666-82cb752b6ed988f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"/></p>\n具体的添加方式是：Libraries上右键--> addFiles to \"项目名\"，选择目录：\nnode_modules/react-native/React/React.xcodeproj或者\nnode_modules/react-native/Libraries/Text/RCTText.xcodeproj\n其他类似。\n#### 6. 将依赖库链接到项目依赖库中。\n<p style=\"text-align: center\"><img src=\"http://upload-images.jianshu.io/upload_images/691666-02b808be67f541d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"/></p>\n#### 7. 在项目的搜索路径中添加：\n$(SRCROOT)/node_modules/react-native/React\n![添加搜索路径](http://upload-images.jianshu.io/upload_images/691666-71077a57d6fc5727.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 8. 设置Other Linker Flag, 添加：-ObjC   -lc++\n<p style=\"text-align: center\"><img src=\"http://upload-images.jianshu.io/upload_images/691666-3f5a5815398fc26e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"/></p>\n#### 9. 修改代码AppDelegate.m\n```objective-c\n - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {\n    if(!self.window){\n        self.window = [[UIWindow alloc]init];\n    }\n    \n    self.window.frame = [[UIScreen mainScreen]bounds];\n    self.window.backgroundColor = [UIColor whiteColor];\n    self.window.rootViewController = [ViewController new];\n    [self.window makeKeyAndVisible];\n    return YES;\n}\n```\n修改ViewController.m\n```objective-c\n - (void)viewDidLoad {\n    [super viewDidLoad];\n    UIButton *searchBtn = [[UIButton alloc]init];\n    searchBtn.frame = CGRectMake(0 + 5, 0, 100, 100);\n    searchBtn.backgroundColor = [UIColor colorWithRed:0.000 green:0.569 blue:1.000 alpha:1];\n    [searchBtn setTitle:@\"搜索\" forState:UIControlStateNormal];\n    [searchBtn setTitle:@\"搜索\" forState:UIControlStateHighlighted];\n    \n    NSURL *jsCodeLocation;\n    jsCodeLocation = [NSURL URLWithString:@\"http://192.168.1.102:8081/index.ios.bundle?platform=ios&dev=true\"];\n    RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation\n                                                        moduleName:@\"Study\"\n                                                 initialProperties:nil\n                                                     launchOptions:nil];\n    rootView.frame = [[UIScreen mainScreen]bounds];\n    [self.view addSubview:rootView];\n    [self.view addSubview:searchBtn];\n}\n```\n#### 10. 添加package.json， index.ios.js\n把test项目目录下面的package.json， index.ios.js拷贝一份到ReactTest项目根目录中一份。<br/>\n<p style=\"text-align: center\"><img src=\"http://upload-images.jianshu.io/upload_images/691666-048fffb98c657b7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\"/></p>\n## 运行\n在Xcode中\n```objective-c\ncommand R\n```\n如果运行出错，请查看下一节中是否有解决方法。\n# 错误信息处理\n\n#### error1: Invariant Violation:Application 项目名 has not been registered.\n\n这个错误的原因是index.ios.js 中的注册名，和代码中的引用名不同；\nindex.ios.js 中\n``` js\nAppRegistry.registerComponent('Study', () => ReactTest);\n```\nios 代码中引用\n``` objective0-c\njsCodeLocation = [NSURL URLWithString:@\"http://192.168.1.102:8081/index.ios.bundle?platform=ios&dev=true\"];\n```\n参考：[React-Native坑1：Invariant Violation:Application 项目名 has not been registered.](http://www.jianshu.com/p/82a09063e61c)\n\n#### error2: Could not connect to development server.\n\n这个错误的原因是localost识别问题。解决方式一，修改host文件。方式二, 使用本机ip, 运行之前首先要启动npm start<br/>\n参考:[react native小试身手](https://blog.hainuo.info/blog/react-native-152.html)[[React Native 运行出现 Could not connect to development server 解决方法](http://www.cnblogs.com/iosapp/p/5301070.html)](http://www.cnblogs.com/iosapp/p/5301070.html)\n#### error3:Native module cannot be null\n这个错误的原因是项目中使用的ReactNative模块没有加入到项目中，解决方式参考集成步骤中的5. 仔细检查自己的项目和报错信息。<br/>\n参考：[[React-native, “Native module cannot be null”](http://stackoverflow.com/questions/38698657/react-native-native-module-cannot-be-null)](http://stackoverflow.com/questions/38698657/react-native-native-module-cannot-be-null)[使用链接库](http://reactnative.cn/docs/0.31/linking-libraries-ios.html#content)[RN 集成到IOS原生应用时，出现 Native module cannot be null原因？](http://bbs.reactnative.cn/topic/2460/rn-%E9%9B%86%E6%88%90%E5%88%B0ios%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E6%97%B6-%E5%87%BA%E7%8E%B0-native-module-cannot-be-null%E5%8E%9F%E5%9B%A0/2)\n\n#### error4:Undefined symbols for architecture x86_64: “std::terminate()”, referenced from运行项目时Xcode报错。<br/>\n\n解决办法:add -lc++ in Other Linker Flags in your xcode project build settings.<br/>\n参考：[undefined-symbols-for-architecture-x86-64-stdterminate-referenced-from](http://stackoverflow.com/questions/37186967/undefined-symbols-for-architecture-x86-64-stdterminate-referenced-from)\n\n# 其他\n\n感谢这位[博主](http://www.jianshu.com/p/5cee43ffec6a)提供的思路<br/>\nDemo下载地址：https://github.com/riverlj/ReactTest.git","tags":["ReactNative"],"categories":["跨平台开发"]}]